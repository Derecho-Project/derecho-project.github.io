<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Derecho: README.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Derecho
   &#160;<span id="projectnumber">1.2</span>
   </div>
   <div id="projectbrief">Distributed systems toolkit for RDMA</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">README.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="README_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Full source documentation can be found at https://derecho-project.github.io/.</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;# Derecho</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;This is the main repository for the Derecho project. It unifies the RDMC, SST, and Derecho modules under a single, easy-to-use repository. </div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;## Organization</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;The code for this project is split into modules that interact only through each others&#39; public interfaces. Each module resides in a directory with its own name, which is why the repository&#39;s root directory is mostly empty. External dependencies are located in the `third_party` directory, and will be pointers to Git submodules whenever possible to reduce code duplication. </div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;## Installation</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;Derecho is a library that helps you build replicated, fault-tolerant services in a datacenter with RDMA networking. Here&#39;s how to start using it in your projects.</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;### Prerequisites</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;* Linux (other operating systems don&#39;t currently support the RDMA features we use)</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;* A C++ compiler supporting C++14: GCC 5.4+ or Clang 3.5+</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;* The following system libraries: `rdmacm` (packaged for Ubuntu as `librdmacm-dev 1.0.21`), and `ibverbs` (packaged for Ubuntu as `libibverbs-dev 1.1.8`).</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;* libboost-dev, libboost-system and libboost-system-dev</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;* CMake 2.8.1 or newer, if you want to use the bundled build scripts</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;### Getting Started</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;Since this repository uses Git submodules to refer to some bundled dependencies, a simple `git clone` will not actually download all the code. To download a complete copy of the project, run</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    git clone --recursive https://github.com/Derecho-Project/derecho-unified.git</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;Once cloning is complete, to compile the code, `cd` into the `derecho-unified` directory and run:</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;* mkdir Release</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;* cd Release</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;* `cmake -DCMAKE_BUILD_TYPE=Release ..`</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;* `make`</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;This will place the binaries and libraries in the sub-dierectories of `Release`.</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;The other build type is Debug. If you need to build the Debug version, replace Release by Debug in the above instructions. We explicitly disable in-source build, so running `cmake .` in `derecho-unified` will not work.</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;To add your own executable (that uses Derecho) to the build system, simply add an executable target to CMakeLists.txt with `derecho` as a &quot;linked library.&quot; You can do this either in the top-level CMakeLists.txt or in the CMakeLists.txt inside the &quot;derecho&quot; directory. It will look something like this:</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    add_executable(my_project_main my_project_main.cpp)</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;   target_link_libraries(my_project_main derecho)</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;To use Derecho in your code, you simply need to include the header `derecho/derecho.h` in your \*.h or \*.cpp files:</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;   </div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;```cpp</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;#include &quot;derecho/derecho.h&quot;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;```</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;### Testing (and some hidden gotchas)</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;There are many experiment files in derecho/experiments that can be run to test the installation. To be able to run the tests, you need a minimum of two machines connected by RDMA. The RDMA devices on the machines should be active. In addition, you need to run the following commands to install and load the required kernel modules:</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;* sudo apt-get install rdmacm-utils rdmacm-utils librdmacm-dev libibverbs-dev ibutils libmlx4-1</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;infiniband-diags libmthca-dev opensm ibverbs-utils libibverbs1 libibcm1 libibcommon1</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;* sudo modprobe -a rdma_cm ib_uverbs ib_umad ib_ipoib mlx4_ib iw_cxgb3 iw_cxgb4 iw_nes iw_c2 ib_mthca</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;Depending on your system, some of the modules might not load which is fine.</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;RDMA requires memory pinning of memory regions shared with other nodes. There&#39;s a limit on the maximum amount of memory a process can pin, typically 64 KB, which Derecho easily exceeds. Therefore, you need to set this to unlimited. To do so, append the following lines to /etc/security/limits.conf:</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;* username hard memlock unlimited</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;* username soft memlock unlimited</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;where username is your linux username. A * in place of username will set this limit to unlimited for all users. Log out and back in again for the limits to reapply. You can test this by verifying that `ulimit -l` outputs `unlimited` in bash.</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;We currently do not have a systematic way of asking the user for RDMA device configuration. So, we pick an arbitrary RDMA device in functions `resources_create` in `sst/verbs.cpp` and `verbs_initialize` in `rdmc/verbs_helper.cpp`. Look for the loop `for(i = 1; i &lt; num_devices; i++)`. If you have a single RDMA device, most likely you want to start `i` from `0`. If you have multiple devices, you want to start `i` from the order (zero-based) of the device you want to use in the list of devices obtained by running `ibv_devices` in bash.</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;To test if one of the experiments is working correctly, go to two of your machines (nodes), `cd` to `Release/derecho/experiments` and run `./derecho_bw_test 0 10000 15 1000 1 0` on both. The programs will ask for input.</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;The input to the first node is:</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;* 0 (it&#39;s node id)</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;* 2 (number of nodes for the experiment)</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;* ip-addr of node 1</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;* ip-addr of node 2</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;Replace the node id 0 by 1 for the input to the second node.</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;As a confirmation that the experiment finished successfully, the first node will write a log of the result in the file `data_derecho_bw` something along the lines of `12 0 10000 15 1000 1 0 0.37282</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;`. Full experiment details including explanation of the arguments, results and methodology is explained in the source documentation at the link given earlier.</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;## Using Derecho</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;The file `typed_subgroup_test.cpp` within derecho/experiments shows a complete working example of a program that sets up and uses a Derecho group with several Replicated Objects. You can read through that file if you prefer to learn by example, or read on for an explanation of how to use various features of Derecho.</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;### Replicated Objects</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;One of the core building blocks of Derecho is the concept of a Replicated Object. This provides a simple way for you to define state that is replicated among several machines and a set of RPC functions that operate on that state.</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;A Replicated Object is any class that (1) is serializable with the mutils-serialization framework and (2) implements a static method called `register_functions()`. The [mutils-serialization](https://github.com/mpmilano/mutils-serialization) library should have more documentation on making objects serializable, but the most straightforward way is to inherit `mutils::ByteRepresentable`, use the macro `DEFAULT_SERIALIZATION_SUPPORT`, and write an element-by-element constructor. The `register_functions()` method is how your class specifies to Derecho which of its methods should be converted to RPC functions and what their numeric &quot;function tags&quot; should be. It should return a `std::tuple` containing a pointer to each RPC-callable method, wrapped in the template function `derecho::rpc::tag`. The template parameter to `tag` is the integer that will be used to identify RPC calls to the corresponding method pointer, so we recommend you use a named constant that has the same name as the method. Here is an example of a Replicated Object declaration:</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;```cpp</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;class Cache : public mutils::ByteRepresentable {</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    std::map&lt;std::string, std::string&gt; cache_map;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;public:</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    void put(const std::string&amp; key, const std::string&amp; value);</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    std::string get(const std::string&amp; key); </div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    bool contains(const std::string&amp; key);</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    bool invalidate(const std::string&amp; key);</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    enum Functions { PUT,</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                     GET,</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;                     CONTAINS,</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;                     INVALIDATE };</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    static auto register_functions() {</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;        return std::make_tuple(derecho::rpc::tag&lt;PUT&gt;(&amp;Cache::put),</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;                               derecho::rpc::tag&lt;GET&gt;(&amp;Cache::get),</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;                               derecho::rpc::tag&lt;CONTAINS&gt;(&amp;Cache::contains),</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;                               derecho::rpc::tag&lt;INVALIDATE&gt;(&amp;Cache::invalidate));</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    }</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    Cache() : cache_map() {}</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    Cache(const std::map&lt;std::string, std::string&gt;&amp; cache_map) : cache_map(cache_map) {}</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    DEFAULT_SERIALIZATION_SUPPORT(Cache, cache_map);</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;};</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;```</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;This object has one field, `cache_map`, so the DEFAULT_SERIALIZATION_SUPPORT macro is called with the name of the class and the name of this field. The second constructor, which initializes the field from a parameter of the same type, is required for serialization support. The object has four RPC methods, `put`, `get`, `contains`, and `invalidate`, and `register_functions()` tags them with enum constants that have similar names.</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;### Groups and Subgroups</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;Derecho organizes nodes (machines or processes in a system) into Groups, which can then be divided into subgroups and shards. Any member of a Group can communicate with any other member, and all run the same group-management service that handles failures and accepts new members. Subgroups, which are any subset of the nodes in a Group, correspond to Replicated Objects; each subgroup replicates the state of a Replicated Object and any member of the subgroup can handle RPC calls on that object. Shards are disjoint subsets of a subgroup that each maintain their own state, so one subgroup can replicate multiple instances of the same type of Replicated Object. A Group must be statically configured with the types of Replicated Objects it can support, but the number of subgroups and their exact membership can change at runtime according to functions that you provide. </div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;Note that more than one subgroup can use the same type of Replicated Object, so there can be multiple independent instances of a Replicated Object in a Group even if those subgroups are not sharded. A subgroup is usually identified by the type of Replicated Object it implements and an integral index number specifying which subgroup of that type it is. </div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;To start using Derecho, a process must either start or join a Group by constructing an instance of `derecho::Group`, which then provides the interface for interacting with other nodes in the Group. (The difference between starting and joining a group is simply a matter of calling a different constructor). A `derecho::Group` expects a set of variadic template parameters representing the types of Replicated Objects that it can support in its subgroups. For example, this declaration is a pointer to a Group object that can have subgroups of type LoadBalancer, Cache, and Storage:</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;```cpp</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;std::unique_ptr&lt;derecho::Group&lt;LoadBalancer, Cache, Storage&gt;&gt; group;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;```</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;#### Defining Subgroup Membership</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;In order to start or join a Group, all members (including processes that join later) must define functions that provide the membership (as a subset of the current View) for each subgroup and shard, given as input the current View. These functions are organized in a map keyed by `std::type_index` in struct SubgroupInfo, where the key for a subgroup-membership function is the type of Replicated Object associated with that subgroup. Since there can be more than one subgroup that implements the same Replicated Object type (as separate instances of the same type of object), the return type of a subgroup membership function is a vector-of-vectors: the index of the outer vector identifies which subgroup is being described, and the inner vector contains an entry for each shard of that subgroup. </div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;Derecho provides a default subgroup membership function that automatically assigns nodes from the Group into disjoint subgroups and shards, given a policy that describes the desired number of nodes in each subgroup/shard. It assigns nodes in ascending rank order, and leaves any &quot;extra&quot; nodes (not needed to fully populate all subgroups) at the end (highest rank) of the membership list. This function is stateful, remembering its previous output from View to View, and at each View change it attempts to preserve the correct number of nodes in each shard without re-assigning any nodes to new roles. It does this by assigning idle nodes from the end of the Group&#39;s membership list to replace failed members of subgroups.</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;There are several helper functions in `subgroup_functions.h` that construct AllocationPolicy objects for different scenarios, to make it easier to set up the default subgroup membership function. Here is an example of a SubgroupInfo that uses these functions to set up two types of Replicated Objects using the default membership function:</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;```cpp</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;derecho::SubgroupInfo subgroup_info {</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;   {{std::type_index(typeid(Foo)), derecho::DefaultSubgroupAllocator(</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;           derecho::one_subgroup_policy(derecho::even_sharding_policy(2, 3)))},</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    {std::type_index(typeid(Bar)), derecho::DefaultSubgroupAllocator(</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;           derecho::identical_subgroups_policy(2, derecho::even_sharding_policy(1, 3)))}</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;   }, </div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;   {std::type_index(typeid(Foo)), std::type_index(typeid(Bar))}</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;};</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;```</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;Based on the policies constructed for the constructor argument of DefaultSubgroupAllocator, the function associated with Foo will create one subgroup of type Foo, with two shards of 3 members each. The function associated with Bar will create two subgroups of type Bar, each of which has only one shard of size 3. Note that the second component of SubgroupInfo is a list of the same Replicated Object types that are in the function map; this list specifies the order in which the membership functions will be run. </div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;More advanced users may, of course, want to define their own subgroup membership functions. We will describe how to do this in a later section of the user guide.</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;#### Constructing a Group</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;Although the SubgroupInfo is the most important part of constructing a `derecho::Group`, it requires several additional parameters.</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;* The **node ID** and **IP address** of the process starting or joining the group</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;* The **IP address of the Group&#39;s leader**, if a process is joining the group. The &quot;leader&quot; is simply the process with the lowest-numbered node ID in the group.</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;* A set of **callback functions** that will be notified when each Derecho message is delivered to the node (stability callback) or persisted to disk (persistence callback). These can be null, and are probably not useful if you&#39;re only using the Replicated Object features of Derecho (since the &quot;messages&quot; will be serialized RPC calls).</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;* For the process that starts the group, the **Derecho parameters** that specify low-level configuration options, such as the maximum size of a message that will be sent in this group and the length of timeout to use for detecting node failures.</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;* A set of **View upcalls** that will be notified when the group experiences a View change event (nodes fail or join the group). This is optional and can be empty, but it can be useful for adding additional failure-handling or load-balancing behavior to your application.</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;* For each template parameter in the type of `derecho::Group`, its constructor will expect an additional argument of type `derecho::Factory`, which is a function or functor that constructs instances of the Replicated Object (it&#39;s just an alias for `std::function&lt;std::unique_ptr&lt;T&gt;(void)&gt;`). </div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;### Invoking RPC Functions</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;Once a process has joined a Group and one or more subgroups, it can invoke RPC functions on any of the Replicated Objects in the Group. The options a process has for invoking RPC functions depend on its membership status:</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;* A node can perform an **ordered query** or **ordered send** to invoke an RPC function on a Replicated Object only when it is a member of that object&#39;s subgroup and shard. Both of these operations send a multicast to all other members of the object&#39;s shard, and guarantee that the multicast will be delivered in order (so the function call will take effect at the same time on every node). An ordered query waits for responses from each member of the shard (specifically, it provides a set of Future objects that can be used to wait for responses), while an ordered send does not wait for responses and thus should only be used to invoke `void` functions.</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;* A node can perform a **P2P query** or **P2P send** to invoke a read-only RPC function on any Replicated Object, regardless of whether it is a member of that object&#39;s subgroup and shard. These peer-to-peer operations send a message directly to a specific node, and it is up to the sender to pick a node that is a member of the desired object&#39;s shard. They cannot be used for mutative RPC function calls because they do not guarantee ordering of the message with respect to any other (peer-to-peer or &quot;ordered&quot;) message, and could only update one replica at a time.</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;Ordered sends and queries are invoked through the `Replicated` interface, whose template parameter is the type of the Replicated Object it communicates with. You can obtain a `Replicated` by using Group&#39;s `get_subgroup` method, which uses a template parameter to specify the type of the Replicated Object and an integer argument to specify which subgroup of that type (remember that more than one subgroup can implement the same type of Replicated Object). For example, this code retrieves the Replicated object corresponding to the second subgroup of type Cache:</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;```cpp</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;Replicated&lt;Cache&gt;&amp; cache_rpc_handle = group-&gt;get_subgroup&lt;Cache&gt;(1);</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;```</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;The `ordered_send` and `ordered_query` methods use their template parameter, which is an integral &quot;function tag,&quot; to specify which RPC function they invoke; this should correspond to the same constant you used to tag that function in the Replicated Object&#39;s `register_functions()` method. Their arguments are the arguments that will be passed to the RPC function call. The `ordered_send` function returns nothing, while the `ordered_query` function returns an instance of `derecho::rpc::QueryResults` with a template parameter equal to the return type of the RPC function. Using the Cache example from earlier, this is what RPC calls to the &quot;put&quot; and &quot;contains&quot; functions would look like:</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;```cpp</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;cache_rpc_handle.ordered_send&lt;Cache::PUT&gt;(&quot;Foo&quot;, &quot;Bar&quot;);</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;derecho::rpc::QueryResults&lt;bool&gt; results = cache_rpc_handle.ordered_query&lt;Cache::CONTAINS&gt;(&quot;Foo&quot;);</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;```</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;P2P (peer-to-peer) sends and queries are invoked through the `ExternalCaller` interface, which is exactly like the `Replicated` interface except it only provides the `p2p_send` and `p2p_query` functions. ExternalCaller objects are provided through the `get_nonmember_subgroup` method of Group, which works exactly like `get_subgroup` (except for the assumption that the caller is not a member of the requested subgroup). For example, this is how a process that is not a member of the second Cache-type subgroup would get an ExternalCaller to that subgroup:</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;```cpp</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;ExternalCaller&lt;Cache&gt;&amp; p2p_cache_handle = group-&gt;get_nonmember_subgroup&lt;Cache&gt;(1);</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;```</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;When invoking a P2P send or query, the caller must specify, as the first argument, the ID of the node to communicate with. The caller must ensure that this node is actually a member of the subgroup that the ExternalCaller targets (though it can be in any shard of that subgroup). For example, if node 5 is in the Cache subgroup targeted above, this is how a non-member process could make a call to `get`:</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;```cpp</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;derecho::rpc::QueryResults&lt;std::string&gt; results = p2p_cache_handle.p2p_query&lt;Cache::GET&gt;(5, &quot;Foo&quot;);</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;```</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;#### Using QueryResults objects</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;The result of an ordered query is a slightly complex object, because it must contain a `std::future` for each member of the subgroup, but the membership of the subgroup might change during the query invocation. Thus, a QueryResults object is actually itself a future, which is fulfilled with a map from node IDs to futures as soon as Derecho can guarantee that the query will be delivered in a particular View. (The node IDs in the map are the members of the subgroup in that View). Each `std::future` in the map will be fulfilled with either the response from that node or a `node_removed_from_group_exception`, if a View change occurred after the query was delivered but before that node had a chance to respond.</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;As an example, this code waits for the responses from each node and combines them to ensure that all replicas agree on an item&#39;s presence in the cache:</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;```cpp</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;derecho::rpc::QueryResults&lt;bool&gt; results = cache_rpc_handle.ordered_query&lt;Cache::CONTAINS&gt;(&quot;Stuff&quot;);</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;bool contains_accum = true;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;for(auto&amp; reply_pair : results.get()) {</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;   bool contains_result = reply_pair.second.get();</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;   contains_accum = contains_accum &amp;&amp; contains_result;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;}</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;```</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;Note that the type of `reply_pair` is `std::pair&lt;derecho::node_id_t, std::future&lt;bool&gt;&gt;`, which is why a node&#39;s response is accessed by writing `reply_pair.second.get()`.</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;### Tracking Updates with Version Vectors</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;Derecho allows tracking data update history with a version vector in memory or persistent storage. A new class template is introduced for this purpose: Persistent&lt;T,ST&gt;. In a Persistent instance, data is managed in an in-memory object of type T (we call it the ‘current object’) along with a log in a datastore specified by storage type ST. The log can be index using a version, an index, or a timestamp. A version is a 64-bit integer attached to each version, it is managed by derecho SST and guaranteed to be monotonic. A log is also an array of versions accessible using zero-based indices. Each log is also attached by a timestamp (microseconds) indicating when this update happens according to local RTC. To enable this feature, we need to manage the data in a serializable object T, and define a member of type Persistent&lt;T&gt; in the Replicated Object in a relevant group. Persistent_typed_subgroup_test.cpp gives an example.</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;```cpp</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;/**</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160; * Example for replicated object with Persistent&lt;T&gt;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160; */</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160; class PFoo : public mutils::ByteRepresentable {</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;  Persistent&lt;int&gt; pint;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160; public:</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;  virtual ~PFoo() noexcept (true) {}</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;  int read_state() {</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    return *pint; </div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;  }</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;  bool change_state(int new_int) {</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    if(new_int == *pint) {</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;      return false;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    }</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160; </div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    *pint = new_int;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    return true;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;  }</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160; </div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;  enum Functions { READ_STATE,</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;                   CHANGE_STATE };</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;  static auto register_functions() {</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    return std::make_tuple(derecho::rpc::tag&lt;READ_STATE&gt;(&amp;PFoo::read_state),</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;      derecho::rpc::tag&lt;CHANGE_STATE&gt;(&amp;PFoo::change_state));</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;  }</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160; </div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;  // constructor for PersistentRegistry</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;  PFoo(PersistentRegistry * pr):pint(nullptr,pr) {}</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;  PFoo(Persistent&lt;int&gt; &amp; init_pint):pint(std::move(init_pint)) {}</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;  DEFAULT_SERIALIZATION_SUPPORT(PFoo, pint);</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160; };</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;```</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;   </div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160; For simplicity, the versioned type is int in this example. Basically, you set it up as a non versioned member of a replicated object except that you need pass the PersistentRegistry to the constructor from the replicated object to Persistent&lt;T&gt;. Derecho uses PersistentRegistry to keep track of all the Persistent&lt;T&gt; objects so that it can create versions on updates.The Persistent&lt;T&gt; constructor hooks itself to the registry.</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;By default, the Persistent&lt;T&gt; stores log in filesystem (.plog in the current directory). Application can specify memory as storage by setting the second template parameter: Persistent&lt;T,ST_MEM&gt; (or Volatile&lt;T&gt; as syntactic sugar). We are working on more store storage types including NVM.</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;Once the version vector is setup with derecho, the application can query the value with the get() APIs in Persistent&lt;T&gt;. In [persistent_temporal_query_test.cpp](https://github.com/Derecho-Project/derecho-unified/blob/master/derecho/experiments/persistent_temporal_query_test.cpp), a temporal query example is illustrated.</div></div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 17 2018 12:49:41 for Derecho by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
