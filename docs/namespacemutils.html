<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Derecho: mutils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Derecho
   &#160;<span id="projectnumber">0.9</span>
   </div>
   <div id="projectbrief">Distributed systems toolkit for RDMA</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mutils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmutils_1_1ByteRepresentable.html">ByteRepresentable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-POD type which wishes to mark itself byte representable should extend this class.  <a href="structmutils_1_1ByteRepresentable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmutils_1_1Bytes.html">Bytes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmutils_1_1ContextDeleter.html">ContextDeleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmutils_1_1ContextDeleter_3_01void_01_4.html">ContextDeleter&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The manager for any RemoteDeserializationContexts.  <a href="structmutils_1_1DeserializationManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structmutils_1_1dsr__info"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemutils.html#structmutils_1_1dsr__info">dsr_info</a></td></tr>
<tr class="separator:structmutils_1_1dsr__info"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmutils_1_1is__list.html">is_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmutils_1_1is__list_3_01std_1_1list_3_01T_01_4_01_4.html">is_list&lt; std::list&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmutils_1_1is__map.html">is_map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmutils_1_1is__map_3_01std_1_1map_3_01K_00_01V_01_4_01_4.html">is_map&lt; std::map&lt; K, V &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmutils_1_1is__pair.html">is_pair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmutils_1_1is__pair_3_01std_1_1pair_3_01T_00_01U_01_4_01_4.html">is_pair&lt; std::pair&lt; T, U &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmutils_1_1is__string.html">is_string</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmutils_1_1is__string_3_01const_01std_1_1string_01_4.html">is_string&lt; const std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmutils_1_1is__string_3_01std_1_1string_01_4.html">is_string&lt; std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmutils_1_1marshalled.html">marshalled</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The "marshalled" type is a wrapper for already-serialized types;.  <a href="structmutils_1_1marshalled.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmutils_1_1RemoteDeserializationContext.html">RemoteDeserializationContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a class which implements <a class="el" href="structmutils_1_1ByteRepresentable.html" title="A non-POD type which wishes to mark itself byte representable should extend this class. ">ByteRepresentable</a> requires a context in order to correctly deserialize, that context should be represented as a class that extends <a class="el" href="structmutils_1_1RemoteDeserializationContext.html" title="If a class which implements ByteRepresentable requires a context in order to correctly deserialize...">RemoteDeserializationContext</a>.  <a href="structmutils_1_1RemoteDeserializationContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afa3f54540dfb84b55fdd44ebf2cab964"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afa3f54540dfb84b55fdd44ebf2cab964"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a> = std::unique_ptr&lt; T, <a class="el" href="structmutils_1_1ContextDeleter.html">ContextDeleter</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:afa3f54540dfb84b55fdd44ebf2cab964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24108de5a796f5c6a879766f84c1833"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemutils.html#ae24108de5a796f5c6a879766f84c1833">RemoteDeserializationContext_p</a> = <a class="el" href="structmutils_1_1RemoteDeserializationContext.html">RemoteDeserializationContext</a> *</td></tr>
<tr class="separator:ae24108de5a796f5c6a879766f84c1833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d378bb5ee06654ecfcf06a4483fcd85"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a6d378bb5ee06654ecfcf06a4483fcd85">RemoteDeserialization_v</a> = std::vector&lt; <a class="el" href="namespacemutils.html#ae24108de5a796f5c6a879766f84c1833">RemoteDeserializationContext_p</a> &gt;</td></tr>
<tr class="separator:a6d378bb5ee06654ecfcf06a4483fcd85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a26ea73da5477cb7510c3a6ef9af05712"><td class="memTemplParams" colspan="2">template&lt;typename T , restrict2(std::is_pod&lt; T &gt;::value) &gt; </td></tr>
<tr class="memitem:a26ea73da5477cb7510c3a6ef9af05712"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a26ea73da5477cb7510c3a6ef9af05712">bytes_size</a> (const T &amp;)</td></tr>
<tr class="memdesc:a26ea73da5477cb7510c3a6ef9af05712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just calls sizeof(T)  <a href="#a26ea73da5477cb7510c3a6ef9af05712">More...</a><br /></td></tr>
<tr class="separator:a26ea73da5477cb7510c3a6ef9af05712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c5994cb59e3a2773c04b93b1284c72"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a82c5994cb59e3a2773c04b93b1284c72">bytes_size</a> (const <a class="el" href="structmutils_1_1ByteRepresentable.html">ByteRepresentable</a> &amp;b)</td></tr>
<tr class="memdesc:a82c5994cb59e3a2773c04b93b1284c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">calls <a class="el" href="namespacemutils.html#ac3918ff232b06aece792629d4e28a792" title="Sums the size of each key and value in the map, plus one int for the number of entries. ">b.bytes_size()</a> when b is a <a class="el" href="structmutils_1_1ByteRepresentable.html" title="A non-POD type which wishes to mark itself byte representable should extend this class. ">ByteRepresentable</a>; calls sizeof(decay_t&lt;decltype(b)&gt;) when b is a POD; custom logic is implemented for some STL types.  <a href="#a82c5994cb59e3a2773c04b93b1284c72">More...</a><br /></td></tr>
<tr class="separator:a82c5994cb59e3a2773c04b93b1284c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeaa47213de374bf3f6207a23323cc2b"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemutils.html#aaeaa47213de374bf3f6207a23323cc2b">bytes_size</a> (const std::string &amp;b)</td></tr>
<tr class="memdesc:aaeaa47213de374bf3f6207a23323cc2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">effectively strlen().  <a href="#aaeaa47213de374bf3f6207a23323cc2b">More...</a><br /></td></tr>
<tr class="separator:aaeaa47213de374bf3f6207a23323cc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75916b6bda08118fbe2b4d7fb30f1781"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a75916b6bda08118fbe2b4d7fb30f1781"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a75916b6bda08118fbe2b4d7fb30f1781">bytes_size</a> (const std::tuple&lt; T... &gt; &amp;t)</td></tr>
<tr class="separator:a75916b6bda08118fbe2b4d7fb30f1781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163f597ed9a5352ab45cf03a420884a1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:a163f597ed9a5352ab45cf03a420884a1"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a163f597ed9a5352ab45cf03a420884a1">bytes_size</a> (const std::pair&lt; T, V &gt; &amp;pair)</td></tr>
<tr class="memdesc:a163f597ed9a5352ab45cf03a420884a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">sums the size of both pair elements  <a href="#a163f597ed9a5352ab45cf03a420884a1">More...</a><br /></td></tr>
<tr class="separator:a163f597ed9a5352ab45cf03a420884a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d8c6b811ebfc06cfb307b31fb27f82"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemutils.html#ab0d8c6b811ebfc06cfb307b31fb27f82">bytes_size</a> (const std::vector&lt; bool &gt; &amp;v)</td></tr>
<tr class="memdesc:ab0d8c6b811ebfc06cfb307b31fb27f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">all of the elements of this vector, plus one int for the number of elements.  <a href="#ab0d8c6b811ebfc06cfb307b31fb27f82">More...</a><br /></td></tr>
<tr class="separator:ab0d8c6b811ebfc06cfb307b31fb27f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5976f728cddd65dc5aec3e4416c8f79"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af5976f728cddd65dc5aec3e4416c8f79"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#af5976f728cddd65dc5aec3e4416c8f79">bytes_size</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:af5976f728cddd65dc5aec3e4416c8f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d49849451a7575c4c5695e90b87dd17"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d49849451a7575c4c5695e90b87dd17"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a8d49849451a7575c4c5695e90b87dd17">bytes_size</a> (const std::list&lt; T &gt; &amp;list)</td></tr>
<tr class="memdesc:a8d49849451a7575c4c5695e90b87dd17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sums the size of all elements of this list, plus one int for the number of elements.  <a href="#a8d49849451a7575c4c5695e90b87dd17">More...</a><br /></td></tr>
<tr class="separator:a8d49849451a7575c4c5695e90b87dd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0901456ae02cdafa4117d551d883163"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac0901456ae02cdafa4117d551d883163"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#ac0901456ae02cdafa4117d551d883163">bytes_size</a> (const std::set&lt; T &gt; &amp;s)</td></tr>
<tr class="memdesc:ac0901456ae02cdafa4117d551d883163"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the elements of the set, plus one int for the number of elements.  <a href="#ac0901456ae02cdafa4117d551d883163">More...</a><br /></td></tr>
<tr class="separator:ac0901456ae02cdafa4117d551d883163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3918ff232b06aece792629d4e28a792"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:ac3918ff232b06aece792629d4e28a792"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#ac3918ff232b06aece792629d4e28a792">bytes_size</a> (const std::map&lt; K, V &gt; &amp;m)</td></tr>
<tr class="memdesc:ac3918ff232b06aece792629d4e28a792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sums the size of each key and value in the map, plus one int for the number of entries.  <a href="#ac3918ff232b06aece792629d4e28a792">More...</a><br /></td></tr>
<tr class="separator:ac3918ff232b06aece792629d4e28a792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f1a2819c849f15c97d1e2221551cec"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:aa0f1a2819c849f15c97d1e2221551cec"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#aa0f1a2819c849f15c97d1e2221551cec">bytes_size_helper</a> (const T &amp;... t)</td></tr>
<tr class="memdesc:aa0f1a2819c849f15c97d1e2221551cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sums the size of each element of the tuple.  <a href="#aa0f1a2819c849f15c97d1e2221551cec">More...</a><br /></td></tr>
<tr class="separator:aa0f1a2819c849f15c97d1e2221551cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d02469455d3abef84eb003370332f65"><td class="memTemplParams" colspan="2">template&lt;typename F , typename BR , typename... Args&gt; </td></tr>
<tr class="memitem:a4d02469455d3abef84eb003370332f65"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_pod&lt; BR &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a4d02469455d3abef84eb003370332f65">post_object</a> (const F &amp;f, const BR &amp;br, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a4d02469455d3abef84eb003370332f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place serialization is also sometimes possible.  <a href="#a4d02469455d3abef84eb003370332f65">More...</a><br /></td></tr>
<tr class="separator:a4d02469455d3abef84eb003370332f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa725535241999ca207b40ce915afdd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemutils.html#aaa725535241999ca207b40ce915afdd5">post_object</a> (const std::function&lt; void(char const *const, std::size_t)&gt; &amp;f, const <a class="el" href="structmutils_1_1ByteRepresentable.html">ByteRepresentable</a> &amp;br)</td></tr>
<tr class="separator:aaa725535241999ca207b40ce915afdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb8cc0912cf726ca32abd4464008da0"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemutils.html#accb8cc0912cf726ca32abd4464008da0">to_bytes</a> (const <a class="el" href="structmutils_1_1ByteRepresentable.html">ByteRepresentable</a> &amp;b, char *v)</td></tr>
<tr class="memdesc:accb8cc0912cf726ca32abd4464008da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">calls b.to_bytes(v) when b is a <a class="el" href="structmutils_1_1ByteRepresentable.html" title="A non-POD type which wishes to mark itself byte representable should extend this class. ">ByteRepresentable</a>; calls std::memcpy() when b is POD.  <a href="#accb8cc0912cf726ca32abd4464008da0">More...</a><br /></td></tr>
<tr class="separator:accb8cc0912cf726ca32abd4464008da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc01f020612459bb04fb5809ff2d10cd"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemutils.html#acc01f020612459bb04fb5809ff2d10cd">to_bytes</a> (const std::string &amp;b, char *v)</td></tr>
<tr class="memdesc:acc01f020612459bb04fb5809ff2d10cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">extracts the C string (char*) equivalent to this std::string and stores it in v  <a href="#acc01f020612459bb04fb5809ff2d10cd">More...</a><br /></td></tr>
<tr class="separator:acc01f020612459bb04fb5809ff2d10cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d8d74055745a9f80adf4a2ce3078fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a53d8d74055745a9f80adf4a2ce3078fd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="structmutils_1_1ByteRepresentable.html">ByteRepresentable</a> CMA T &gt;::value, std::unique_ptr&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a53d8d74055745a9f80adf4a2ce3078fd">from_bytes</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *ctx, char const *v)</td></tr>
<tr class="memdesc:a53d8d74055745a9f80adf4a2ce3078fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls T::from_bytes(ctx,v) when T is a <a class="el" href="structmutils_1_1ByteRepresentable.html" title="A non-POD type which wishes to mark itself byte representable should extend this class. ">ByteRepresentable</a>.  <a href="#a53d8d74055745a9f80adf4a2ce3078fd">More...</a><br /></td></tr>
<tr class="separator:a53d8d74055745a9f80adf4a2ce3078fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0754aface6019217009d82765d1a87c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa0754aface6019217009d82765d1a87c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_pod&lt; T &gt;::value, std::unique_ptr&lt; std::decay_t&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#aa0754aface6019217009d82765d1a87c">from_bytes</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *, char const *v)</td></tr>
<tr class="memdesc:aa0754aface6019217009d82765d1a87c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls T::from_bytes(ctx,v) when T is a <a class="el" href="structmutils_1_1ByteRepresentable.html" title="A non-POD type which wishes to mark itself byte representable should extend this class. ">ByteRepresentable</a>.  <a href="#aa0754aface6019217009d82765d1a87c">More...</a><br /></td></tr>
<tr class="separator:aa0754aface6019217009d82765d1a87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4075de66a3e1a655e479faf369ab5b91"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4075de66a3e1a655e479faf369ab5b91"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="structmutils_1_1ByteRepresentable.html">ByteRepresentable</a> CMA std::decay_t&lt; T &gt; &gt;::value, <a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a4075de66a3e1a655e479faf369ab5b91">from_bytes_noalloc</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *ctx, const char *v, <a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; std::decay_t&lt; T &gt;&gt;=<a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; std::decay_t&lt; T &gt;&gt;{})</td></tr>
<tr class="memdesc:a4075de66a3e1a655e479faf369ab5b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls T::from_bytes_noalloc(ctx,v) when T is a <a class="el" href="structmutils_1_1ByteRepresentable.html" title="A non-POD type which wishes to mark itself byte representable should extend this class. ">ByteRepresentable</a>.  <a href="#a4075de66a3e1a655e479faf369ab5b91">More...</a><br /></td></tr>
<tr class="separator:a4075de66a3e1a655e479faf369ab5b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac832c4bc18d32412c220e534ceca0f28"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac832c4bc18d32412c220e534ceca0f28"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_pod&lt; T &gt;::value, <a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#ac832c4bc18d32412c220e534ceca0f28">from_bytes_noalloc</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *, char *v)</td></tr>
<tr class="memdesc:ac832c4bc18d32412c220e534ceca0f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls T::from_bytes_noalloc(ctx,v) when T is a <a class="el" href="structmutils_1_1ByteRepresentable.html" title="A non-POD type which wishes to mark itself byte representable should extend this class. ">ByteRepresentable</a>.  <a href="#ac832c4bc18d32412c220e534ceca0f28">More...</a><br /></td></tr>
<tr class="separator:ac832c4bc18d32412c220e534ceca0f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cccf58fb1e428e00c8046e83f5ca518"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6cccf58fb1e428e00c8046e83f5ca518"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_pod&lt; T &gt;::value, <a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; const std::decay_t&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a6cccf58fb1e428e00c8046e83f5ca518">from_bytes_noalloc</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *, char const *const v, <a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt;=<a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt;{})</td></tr>
<tr class="separator:a6cccf58fb1e428e00c8046e83f5ca518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0800f4fba0eaa1f799b9e9e100ff7b5b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a0800f4fba0eaa1f799b9e9e100ff7b5b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a0800f4fba0eaa1f799b9e9e100ff7b5b">deserialize_and_run</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *dsm, char *v, const F &amp;fun)</td></tr>
<tr class="memdesc:a0800f4fba0eaa1f799b9e9e100ff7b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls mutils::from_bytes_noalloc&lt;T&gt;(ctx,v), dereferences the result, and passes it to fun.  <a href="#a0800f4fba0eaa1f799b9e9e100ff7b5b">More...</a><br /></td></tr>
<tr class="separator:a0800f4fba0eaa1f799b9e9e100ff7b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8595658650a4286eccb9bfa6ba2cdfab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a8595658650a4286eccb9bfa6ba2cdfab">post_object</a> (const std::function&lt; void(char const *const, std::size_t)&gt; &amp;f, const std::string &amp;str)</td></tr>
<tr class="separator:a8595658650a4286eccb9bfa6ba2cdfab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34609d3a9218115f434b3a0db41b12ad"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:a34609d3a9218115f434b3a0db41b12ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a34609d3a9218115f434b3a0db41b12ad">post_object</a> (const std::function&lt; void(char const *const, std::size_t)&gt; &amp;f, const std::pair&lt; T, V &gt; &amp;pair)</td></tr>
<tr class="separator:a34609d3a9218115f434b3a0db41b12ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918911f9636af6296afa8ce7fc44d72a"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a918911f9636af6296afa8ce7fc44d72a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a918911f9636af6296afa8ce7fc44d72a">post_object_helper</a> (const std::function&lt; void(char const *const, std::size_t)&gt; &amp;f, const T &amp;... t)</td></tr>
<tr class="separator:a918911f9636af6296afa8ce7fc44d72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c3c40f00cbae421d8f3219d1f807d0"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a71c3c40f00cbae421d8f3219d1f807d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a71c3c40f00cbae421d8f3219d1f807d0">post_object</a> (const std::function&lt; void(char const *const, std::size_t)&gt; &amp;f, const std::tuple&lt; T... &gt; &amp;t)</td></tr>
<tr class="separator:a71c3c40f00cbae421d8f3219d1f807d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6165999eb1ed1f436f8f312fee8a4a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemutils.html#ab6165999eb1ed1f436f8f312fee8a4a2">post_object</a> (const std::function&lt; void(char const *const, std::size_t)&gt; &amp;f, const std::vector&lt; bool &gt; &amp;vec)</td></tr>
<tr class="separator:ab6165999eb1ed1f436f8f312fee8a4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a83762098a03c2a41d7cc59323fdac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a33a83762098a03c2a41d7cc59323fdac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a33a83762098a03c2a41d7cc59323fdac">post_object</a> (const std::function&lt; void(char const *const, std::size_t)&gt; &amp;f, const std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:a33a83762098a03c2a41d7cc59323fdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e9ca251aad4bac4a715129268d4d9d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a81e9ca251aad4bac4a715129268d4d9d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a81e9ca251aad4bac4a715129268d4d9d">post_object</a> (const std::function&lt; void(char const *const, std::size_t)&gt; &amp;f, const std::list&lt; T &gt; &amp;list)</td></tr>
<tr class="separator:a81e9ca251aad4bac4a715129268d4d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092156e791ace0b17c9a54019312516c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a092156e791ace0b17c9a54019312516c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a092156e791ace0b17c9a54019312516c">post_object</a> (const std::function&lt; void(char const *const, std::size_t)&gt; &amp;f, const std::set&lt; T &gt; &amp;s)</td></tr>
<tr class="separator:a092156e791ace0b17c9a54019312516c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663a95782d14c5b80b669b0529a81c48"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a663a95782d14c5b80b669b0529a81c48"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a663a95782d14c5b80b669b0529a81c48">post_object</a> (const std::function&lt; void(char const *const, std::size_t)&gt; &amp;f, const std::map&lt; K, V &gt; &amp;map)</td></tr>
<tr class="separator:a663a95782d14c5b80b669b0529a81c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b58f9069bb55f2c99f6f17505995a7"><td class="memTemplParams" colspan="2">template&lt;typename T , restrict(std::is_pod&lt; T &gt;::value) &gt; </td></tr>
<tr class="memitem:a18b58f9069bb55f2c99f6f17505995a7"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a18b58f9069bb55f2c99f6f17505995a7">to_bytes</a> (const T &amp;t, char *v)</td></tr>
<tr class="memdesc:a18b58f9069bb55f2c99f6f17505995a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special to_bytes for POD types, which just uses memcpy.  <a href="#a18b58f9069bb55f2c99f6f17505995a7">More...</a><br /></td></tr>
<tr class="separator:a18b58f9069bb55f2c99f6f17505995a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168a05db072825e5c6df02efa72ac637"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a168a05db072825e5c6df02efa72ac637">to_bytes</a> (const std::vector&lt; bool &gt; &amp;vec, char *v)</td></tr>
<tr class="separator:a168a05db072825e5c6df02efa72ac637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa69a03d0ec336623d8b9a5962c603e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaaa69a03d0ec336623d8b9a5962c603e"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#aaaa69a03d0ec336623d8b9a5962c603e">to_bytes</a> (const std::vector&lt; T &gt; &amp;vec, char *v)</td></tr>
<tr class="separator:aaaa69a03d0ec336623d8b9a5962c603e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af999a678ae4fc3437be0405d9ea1bb18"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af999a678ae4fc3437be0405d9ea1bb18"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#af999a678ae4fc3437be0405d9ea1bb18">to_bytes</a> (const std::list&lt; T &gt; &amp;list, char *buffer)</td></tr>
<tr class="separator:af999a678ae4fc3437be0405d9ea1bb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d490f1e6cb1de193ab0a7aa05ee6ce3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:a2d490f1e6cb1de193ab0a7aa05ee6ce3"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a2d490f1e6cb1de193ab0a7aa05ee6ce3">to_bytes</a> (const std::pair&lt; T, V &gt; &amp;pair, char *buffer)</td></tr>
<tr class="separator:a2d490f1e6cb1de193ab0a7aa05ee6ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bac3fa5951650db15122286fe13f1a0"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a1bac3fa5951650db15122286fe13f1a0"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a1bac3fa5951650db15122286fe13f1a0">to_bytes</a> (const std::tuple&lt; T... &gt; &amp;tuple, char *buffer)</td></tr>
<tr class="separator:a1bac3fa5951650db15122286fe13f1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e554be68e29d12bab9b44ac1dfda09"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab5e554be68e29d12bab9b44ac1dfda09"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#ab5e554be68e29d12bab9b44ac1dfda09">to_bytes</a> (const std::set&lt; T &gt; &amp;s, char *_v)</td></tr>
<tr class="separator:ab5e554be68e29d12bab9b44ac1dfda09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74a255f730d50b17da9540023910380"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:af74a255f730d50b17da9540023910380"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#af74a255f730d50b17da9540023910380">to_bytes</a> (const std::map&lt; K, V &gt; &amp;m, char *buffer)</td></tr>
<tr class="separator:af74a255f730d50b17da9540023910380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ecdecf3792422b475186265f42a15a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae6ecdecf3792422b475186265f42a15a"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; type_check&lt; std::is_integral, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#ae6ecdecf3792422b475186265f42a15a">from_string</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *, char const *v, std::size_t length)</td></tr>
<tr class="separator:ae6ecdecf3792422b475186265f42a15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d54553e3bca7e7325cfd42d855b902c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0d54553e3bca7e7325cfd42d855b902c"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; type_check&lt; std::is_floating_point, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a0d54553e3bca7e7325cfd42d855b902c">from_string</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *, char const *v, std::size_t length)</td></tr>
<tr class="separator:a0d54553e3bca7e7325cfd42d855b902c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf94e92dd45023174778ac9637aabd5f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf94e92dd45023174778ac9637aabd5f"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; type_check&lt; <a class="el" href="structmutils_1_1is__string.html">is_string</a>, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#aaf94e92dd45023174778ac9637aabd5f">from_string</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *, char const *v, std::size_t length)</td></tr>
<tr class="separator:aaf94e92dd45023174778ac9637aabd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac335771f68029fb5ee34f49748beeb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2ac335771f68029fb5ee34f49748beeb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_pod&lt; T &gt;::value, <a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a2ac335771f68029fb5ee34f49748beeb">from_bytes_noalloc</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *, char *v, <a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt;=<a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt;{})</td></tr>
<tr class="separator:a2ac335771f68029fb5ee34f49748beeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df4916755421ab9b43f6c5d73f158aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0df4916755421ab9b43f6c5d73f158aa"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; type_check&lt; <a class="el" href="structmutils_1_1is__string.html">is_string</a>, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a0df4916755421ab9b43f6c5d73f158aa">from_bytes</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *, char const *v)</td></tr>
<tr class="separator:a0df4916755421ab9b43f6c5d73f158aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cb84f12b4ea50d904b0ce2a666595d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa2cb84f12b4ea50d904b0ce2a666595d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; type_check&lt; <a class="el" href="structmutils_1_1is__string.html">is_string</a>, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#aa2cb84f12b4ea50d904b0ce2a666595d">from_bytes_noalloc</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *, char const *v, <a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt;=<a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt;{})</td></tr>
<tr class="separator:aa2cb84f12b4ea50d904b0ce2a666595d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafdbf4d88f30cabc8dd2d565ee41035"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afafdbf4d88f30cabc8dd2d565ee41035"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; type_check&lt; is_set, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#afafdbf4d88f30cabc8dd2d565ee41035">from_bytes</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *ctx, const char *_v)</td></tr>
<tr class="separator:afafdbf4d88f30cabc8dd2d565ee41035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103ad3a62e1f1c83e133eabcbf3d65db"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a103ad3a62e1f1c83e133eabcbf3d65db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; type_check&lt; is_set, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a103ad3a62e1f1c83e133eabcbf3d65db">from_bytes_noalloc</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *ctx, char const *v, <a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt;=<a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt;{})</td></tr>
<tr class="separator:a103ad3a62e1f1c83e133eabcbf3d65db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5f740ec09901c9e010ac6ac807cd8e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f5f740ec09901c9e010ac6ac807cd8e"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; type_check&lt; <a class="el" href="structmutils_1_1is__pair.html">is_pair</a>, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a4f5f740ec09901c9e010ac6ac807cd8e">from_bytes</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *ctx, const char *v)</td></tr>
<tr class="separator:a4f5f740ec09901c9e010ac6ac807cd8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88cdd98ea9c3cd91a60487734ef248a"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:ae88cdd98ea9c3cd91a60487734ef248a"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; type_check&lt; <a class="el" href="structmutils_1_1is__list.html">is_list</a>, L &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#ae88cdd98ea9c3cd91a60487734ef248a">from_bytes</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *ctx, const char *buffer)</td></tr>
<tr class="separator:ae88cdd98ea9c3cd91a60487734ef248a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c6ac6fab9cf86dce2fb6c2dc0f51f5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a78c6ac6fab9cf86dce2fb6c2dc0f51f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; type_check&lt; <a class="el" href="structmutils_1_1is__pair.html">is_pair</a>, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a78c6ac6fab9cf86dce2fb6c2dc0f51f5">from_bytes_noalloc</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *ctx, char const *v, <a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt;=<a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt;{})</td></tr>
<tr class="separator:a78c6ac6fab9cf86dce2fb6c2dc0f51f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fcc8d06983e8a70416eca8e888e62f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a40fcc8d06983e8a70416eca8e888e62f"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a40fcc8d06983e8a70416eca8e888e62f">boolvec_from_bytes</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *ctx, char const *v)</td></tr>
<tr class="separator:a40fcc8d06983e8a70416eca8e888e62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0a041a4b3d61e839b69c4b0edaa4bd"><td class="memTemplParams" colspan="2">template&lt;typename TupleType , std::size_t N&gt; </td></tr>
<tr class="memitem:aae0a041a4b3d61e839b69c4b0edaa4bd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#aae0a041a4b3d61e839b69c4b0edaa4bd">from_bytes_helper</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *ctx, char const *v)</td></tr>
<tr class="separator:aae0a041a4b3d61e839b69c4b0edaa4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f3432eacfe87bf1fee691005f2a0f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a55f3432eacfe87bf1fee691005f2a0f3"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; type_check&lt; is_tuple, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a55f3432eacfe87bf1fee691005f2a0f3">from_bytes</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *ctx, char const *v)</td></tr>
<tr class="separator:a55f3432eacfe87bf1fee691005f2a0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc97f8bdbe15a0e6107cefd5efdaa7e9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abc97f8bdbe15a0e6107cefd5efdaa7e9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; is_vector&lt; T &gt;::value, std::unique_ptr&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#abc97f8bdbe15a0e6107cefd5efdaa7e9">from_bytes</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *ctx, char const *v)</td></tr>
<tr class="separator:abc97f8bdbe15a0e6107cefd5efdaa7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde2cde7b86d3eea73a7be040edb7969"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adde2cde7b86d3eea73a7be040edb7969"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; type_check&lt; is_vector, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#adde2cde7b86d3eea73a7be040edb7969">from_bytes_noalloc</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *ctx, char const *v, <a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt;=<a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt;{})</td></tr>
<tr class="separator:adde2cde7b86d3eea73a7be040edb7969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae567b19db7b4ef1932baa810850fc727"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae567b19db7b4ef1932baa810850fc727"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structmutils_1_1is__map.html">is_map</a>&lt; T &gt;::value, std::unique_ptr&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#ae567b19db7b4ef1932baa810850fc727">from_bytes</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *ctx, char const *buffer)</td></tr>
<tr class="separator:ae567b19db7b4ef1932baa810850fc727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e95e6572d85eac8a59b2095582c8662"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3e95e6572d85eac8a59b2095582c8662"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; type_check&lt; <a class="el" href="structmutils_1_1is__map.html">is_map</a>, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a3e95e6572d85eac8a59b2095582c8662">from_bytes_noalloc</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *ctx, char const *v, <a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt;=<a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt;{})</td></tr>
<tr class="separator:a3e95e6572d85eac8a59b2095582c8662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04efc07fef62de5e7f9f5ebe28b34fa6"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a04efc07fef62de5e7f9f5ebe28b34fa6">to_bytes_v</a> (char *)</td></tr>
<tr class="memdesc:a04efc07fef62de5e7f9f5ebe28b34fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For Serializing and Deserializing many objects at once.  <a href="#a04efc07fef62de5e7f9f5ebe28b34fa6">More...</a><br /></td></tr>
<tr class="separator:a04efc07fef62de5e7f9f5ebe28b34fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1576041e86f15fb3c967b422fbd22a4f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Rest&gt; </td></tr>
<tr class="memitem:a1576041e86f15fb3c967b422fbd22a4f"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a1576041e86f15fb3c967b422fbd22a4f">to_bytes_v</a> (char *buf, const T &amp;first, const Rest &amp;... rest)</td></tr>
<tr class="separator:a1576041e86f15fb3c967b422fbd22a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27d3c4d2ac579c4ba2f689bbdbfa2f4"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemutils.html#ae27d3c4d2ac579c4ba2f689bbdbfa2f4">from_bytes_v</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *, char const *const)</td></tr>
<tr class="separator:ae27d3c4d2ac579c4ba2f689bbdbfa2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5e93567b27ce9d2b29a4d119390c43"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Rest&gt; </td></tr>
<tr class="memitem:a2d5e93567b27ce9d2b29a4d119390c43"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a2d5e93567b27ce9d2b29a4d119390c43">from_bytes_v</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *dsm, char const *const buf, std::unique_ptr&lt; T &gt; &amp;first, Rest &amp;... rest)</td></tr>
<tr class="separator:a2d5e93567b27ce9d2b29a4d119390c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a37a487b89fc04b74696da5269cc803"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a8a37a487b89fc04b74696da5269cc803">from_bytes_noalloc_v</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *, char const *const)</td></tr>
<tr class="separator:a8a37a487b89fc04b74696da5269cc803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2002016cd37fc94a4015cc81e0f37226"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Rest&gt; </td></tr>
<tr class="memitem:a2002016cd37fc94a4015cc81e0f37226"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a2002016cd37fc94a4015cc81e0f37226">from_bytes_noalloc_v_nc</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *dsm, char *buf, <a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt; &amp;first, <a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; Rest &gt; &amp;... rest)</td></tr>
<tr class="separator:a2002016cd37fc94a4015cc81e0f37226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f15ac4d92b13ea311cf6e2946c014e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Rest&gt; </td></tr>
<tr class="memitem:a34f15ac4d92b13ea311cf6e2946c014e"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a34f15ac4d92b13ea311cf6e2946c014e">from_bytes_noalloc_v</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *dsm, char *buf, <a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt; &amp;first, <a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; Rest &gt; &amp;... rest)</td></tr>
<tr class="separator:a34f15ac4d92b13ea311cf6e2946c014e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ddd510198109b06198421baa60b383"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Rest&gt; </td></tr>
<tr class="memitem:a40ddd510198109b06198421baa60b383"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a40ddd510198109b06198421baa60b383">from_bytes_noalloc_v</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *dsm, char const *const buf, <a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; const T &gt; &amp;first, <a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; const Rest &gt; &amp;... rest)</td></tr>
<tr class="separator:a40ddd510198109b06198421baa60b383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1fcc9de498eb1d8619bcbf8e21d8db"><td class="memTemplParams" colspan="2">template&lt;typename F , typename R , typename... Args&gt; </td></tr>
<tr class="memitem:a1d1fcc9de498eb1d8619bcbf8e21d8db"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a1d1fcc9de498eb1d8619bcbf8e21d8db">deserialize_and_run</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *dsm, char const *const v, const F &amp;fun, std::function&lt; R(Args...)&gt; const *const)</td></tr>
<tr class="separator:a1d1fcc9de498eb1d8619bcbf8e21d8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66c0dfca7ef8430a262755744ebf01e"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ac66c0dfca7ef8430a262755744ebf01e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemutils.html#ac66c0dfca7ef8430a262755744ebf01e">deserialize_and_run</a> (<a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *dsm, char const *const v, const F &amp;fun)</td></tr>
<tr class="separator:ac66c0dfca7ef8430a262755744ebf01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60aac469a3b3f189c4a1f49b99803e33"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(char const  *const, std::size_t)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a60aac469a3b3f189c4a1f49b99803e33">post_to_buffer</a> (std::size_t &amp;index, char *dest_buf)</td></tr>
<tr class="separator:a60aac469a3b3f189c4a1f49b99803e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a873b640a01cd43188b97edcf394c5213"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(char const  *const, std::size_t)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemutils.html#a873b640a01cd43188b97edcf394c5213">post_to_buffer</a> (std::size_t &amp;index, char *dest_buf)</td></tr>
<tr class="memdesc:a873b640a01cd43188b97edcf394c5213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization is also implemented for the following STL types: vector pair string set.  <a href="#a873b640a01cd43188b97edcf394c5213">More...</a><br /></td></tr>
<tr class="separator:a873b640a01cd43188b97edcf394c5213"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structmutils_1_1dsr__info" id="structmutils_1_1dsr__info"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structmutils_1_1dsr__info">&#9670;&nbsp;</a></span>mutils::dsr_info</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct mutils::dsr_info</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00954">954</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="af78c6c668201aded03ca5ef67cb02ef0"></a>time_point</td>
<td class="fieldname">
start_time</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a9d6d4707b61f2bc2623b584cabcbaa05"></a>nanoseconds</td>
<td class="fieldname">
to_callfunc</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a2dd3732c6a1b0585b74330cee81cb9bd"></a>nanoseconds</td>
<td class="fieldname">
to_exit</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="afa3f54540dfb84b55fdd44ebf2cab964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3f54540dfb84b55fdd44ebf2cab964">&#9670;&nbsp;</a></span>context_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">mutils::context_ptr</a> = typedef std::unique_ptr&lt;T,<a class="el" href="structmutils_1_1ContextDeleter.html">ContextDeleter</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="context__ptr_8hpp_source.html#l00020">20</a> of file <a class="el" href="context__ptr_8hpp_source.html">context_ptr.hpp</a>.</p>

</div>
</div>
<a id="a6d378bb5ee06654ecfcf06a4483fcd85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d378bb5ee06654ecfcf06a4483fcd85">&#9670;&nbsp;</a></span>RemoteDeserialization_v</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemutils.html#a6d378bb5ee06654ecfcf06a4483fcd85">mutils::RemoteDeserialization_v</a> = typedef std::vector&lt;<a class="el" href="namespacemutils.html#ae24108de5a796f5c6a879766f84c1833">RemoteDeserializationContext_p</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00121">121</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="ae24108de5a796f5c6a879766f84c1833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24108de5a796f5c6a879766f84c1833">&#9670;&nbsp;</a></span>RemoteDeserializationContext_p</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemutils.html#ae24108de5a796f5c6a879766f84c1833">mutils::RemoteDeserializationContext_p</a> = typedef <a class="el" href="structmutils_1_1RemoteDeserializationContext.html">RemoteDeserializationContext</a>*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00116">116</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a40fcc8d06983e8a70416eca8e888e62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40fcc8d06983e8a70416eca8e888e62f">&#9670;&nbsp;</a></span>boolvec_from_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;T&gt; mutils::boolvec_from_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a26ea73da5477cb7510c3a6ef9af05712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ea73da5477cb7510c3a6ef9af05712">&#9670;&nbsp;</a></span>bytes_size() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , restrict2(std::is_pod&lt; T &gt;::value) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mutils::bytes_size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Just calls sizeof(T) </p>

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00201">201</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a82c5994cb59e3a2773c04b93b1284c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c5994cb59e3a2773c04b93b1284c72">&#9670;&nbsp;</a></span>bytes_size() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::bytes_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmutils_1_1ByteRepresentable.html">ByteRepresentable</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calls <a class="el" href="namespacemutils.html#ac3918ff232b06aece792629d4e28a792" title="Sums the size of each key and value in the map, plus one int for the number of entries. ">b.bytes_size()</a> when b is a <a class="el" href="structmutils_1_1ByteRepresentable.html" title="A non-POD type which wishes to mark itself byte representable should extend this class. ">ByteRepresentable</a>; calls sizeof(decay_t&lt;decltype(b)&gt;) when b is a POD; custom logic is implemented for some STL types. </p>

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8cpp_source.html#l00011">11</a> of file <a class="el" href="SerializationSupport_8cpp_source.html">SerializationSupport.cpp</a>.</p>

</div>
</div>
<a id="aaeaa47213de374bf3f6207a23323cc2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeaa47213de374bf3f6207a23323cc2b">&#9670;&nbsp;</a></span>bytes_size() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::bytes_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>effectively strlen(). </p>

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8cpp_source.html#l00020">20</a> of file <a class="el" href="SerializationSupport_8cpp_source.html">SerializationSupport.cpp</a>.</p>

</div>
</div>
<a id="a75916b6bda08118fbe2b4d7fb30f1781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75916b6bda08118fbe2b4d7fb30f1781">&#9670;&nbsp;</a></span>bytes_size() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::bytes_size </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00299">299</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a163f597ed9a5352ab45cf03a420884a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163f597ed9a5352ab45cf03a420884a1">&#9670;&nbsp;</a></span>bytes_size() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::bytes_size </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; T, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>pair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sums the size of both pair elements </p>

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00224">224</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="ab0d8c6b811ebfc06cfb307b31fb27f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0d8c6b811ebfc06cfb307b31fb27f82">&#9670;&nbsp;</a></span>bytes_size() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::bytes_size </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>all of the elements of this vector, plus one int for the number of elements. </p>

</div>
</div>
<a id="af5976f728cddd65dc5aec3e4416c8f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5976f728cddd65dc5aec3e4416c8f79">&#9670;&nbsp;</a></span>bytes_size() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::bytes_size </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00234">234</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a8d49849451a7575c4c5695e90b87dd17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d49849451a7575c4c5695e90b87dd17">&#9670;&nbsp;</a></span>bytes_size() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::bytes_size </td>
          <td>(</td>
          <td class="paramtype">const std::list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sums the size of all elements of this list, plus one int for the number of elements. </p>

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00254">254</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="ac0901456ae02cdafa4117d551d883163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0901456ae02cdafa4117d551d883163">&#9670;&nbsp;</a></span>bytes_size() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::bytes_size </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All the elements of the set, plus one int for the number of elements. </p>

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00269">269</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="ac3918ff232b06aece792629d4e28a792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3918ff232b06aece792629d4e28a792">&#9670;&nbsp;</a></span>bytes_size() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::bytes_size </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sums the size of each key and value in the map, plus one int for the number of entries. </p>

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00282">282</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="aa0f1a2819c849f15c97d1e2221551cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f1a2819c849f15c97d1e2221551cec">&#9670;&nbsp;</a></span>bytes_size_helper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::bytes_size_helper </td>
          <td>(</td>
          <td class="paramtype">const T &amp;...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sums the size of each element of the tuple. </p>

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00295">295</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a0800f4fba0eaa1f799b9e9e100ff7b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0800f4fba0eaa1f799b9e9e100ff7b5b">&#9670;&nbsp;</a></span>deserialize_and_run() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mutils::deserialize_and_run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname"><em>dsm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls mutils::from_bytes_noalloc&lt;T&gt;(ctx,v), dereferences the result, and passes it to fun. </p>
<p>Returns whatever fun returns. Memory safe, assuming fun doesn't do something stupid. </p>

</div>
</div>
<a id="a1d1fcc9de498eb1d8619bcbf8e21d8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1fcc9de498eb1d8619bcbf8e21d8db">&#9670;&nbsp;</a></span>deserialize_and_run() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename R , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mutils::deserialize_and_run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname"><em>dsm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; R(Args...)&gt; const *&#160;</td>
          <td class="paramname"><em>const</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00966">966</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="ac66c0dfca7ef8430a262755744ebf01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66c0dfca7ef8430a262755744ebf01e">&#9670;&nbsp;</a></span>deserialize_and_run() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mutils::deserialize_and_run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname"><em>dsm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l01020">1020</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a53d8d74055745a9f80adf4a2ce3078fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d8d74055745a9f80adf4a2ce3078fd">&#9670;&nbsp;</a></span>from_bytes() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="structmutils_1_1ByteRepresentable.html">ByteRepresentable</a> CMA T&gt;::value, std::unique_ptr&lt;T&gt; &gt; mutils::from_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls T::from_bytes(ctx,v) when T is a <a class="el" href="structmutils_1_1ByteRepresentable.html" title="A non-POD type which wishes to mark itself byte representable should extend this class. ">ByteRepresentable</a>. </p>
<p>uses std::memcpy() when T is a POD. custom logic is implemented for some STL types. </p>

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00356">356</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="aa0754aface6019217009d82765d1a87c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0754aface6019217009d82765d1a87c">&#9670;&nbsp;</a></span>from_bytes() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_pod&lt; T &gt;::value, std::unique_ptr&lt; std::decay_t&lt; T &gt; &gt; &gt; mutils::from_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls T::from_bytes(ctx,v) when T is a <a class="el" href="structmutils_1_1ByteRepresentable.html" title="A non-POD type which wishes to mark itself byte representable should extend this class. ">ByteRepresentable</a>. </p>
<p>uses std::memcpy() when T is a POD. custom logic is implemented for some STL types. </p>

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00684">684</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a0df4916755421ab9b43f6c5d73f158aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df4916755421ab9b43f6c5d73f158aa">&#9670;&nbsp;</a></span>from_bytes() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;type_check&lt;<a class="el" href="structmutils_1_1is__string.html">is_string</a>, T&gt; &gt; mutils::from_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00739">739</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="afafdbf4d88f30cabc8dd2d565ee41035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afafdbf4d88f30cabc8dd2d565ee41035">&#9670;&nbsp;</a></span>from_bytes() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;type_check&lt;is_set, T&gt; &gt; mutils::from_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00754">754</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a4f5f740ec09901c9e010ac6ac807cd8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5f740ec09901c9e010ac6ac807cd8e">&#9670;&nbsp;</a></span>from_bytes() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;type_check&lt;<a class="el" href="structmutils_1_1is__pair.html">is_pair</a>, T&gt; &gt; mutils::from_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00775">775</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="ae88cdd98ea9c3cd91a60487734ef248a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88cdd98ea9c3cd91a60487734ef248a">&#9670;&nbsp;</a></span>from_bytes() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;type_check&lt;<a class="el" href="structmutils_1_1is__list.html">is_list</a>, L&gt; &gt; mutils::from_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00785">785</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a55f3432eacfe87bf1fee691005f2a0f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f3432eacfe87bf1fee691005f2a0f3">&#9670;&nbsp;</a></span>from_bytes() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;type_check&lt;is_tuple, T&gt; &gt; mutils::from_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00823">823</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="abc97f8bdbe15a0e6107cefd5efdaa7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc97f8bdbe15a0e6107cefd5efdaa7e9">&#9670;&nbsp;</a></span>from_bytes() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;is_vector&lt;T&gt;::value, std::unique_ptr&lt;T&gt; &gt; mutils::from_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00830">830</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="ae567b19db7b4ef1932baa810850fc727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae567b19db7b4ef1932baa810850fc727">&#9670;&nbsp;</a></span>from_bytes() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structmutils_1_1is__map.html">is_map</a>&lt;T&gt;::value, std::unique_ptr&lt;T&gt; &gt; mutils::from_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00874">874</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="aae0a041a4b3d61e839b69c4b0edaa4bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0a041a4b3d61e839b69c4b0edaa4bd">&#9670;&nbsp;</a></span>from_bytes_helper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mutils::from_bytes_helper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00811">811</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a4075de66a3e1a655e479faf369ab5b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4075de66a3e1a655e479faf369ab5b91">&#9670;&nbsp;</a></span>from_bytes_noalloc() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="structmutils_1_1ByteRepresentable.html">ByteRepresentable</a> CMA std::decay_t&lt; T &gt; &gt;::value, <a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt; &gt; mutils::from_bytes_noalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; std::decay_t&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt;std::decay_t&lt;T&gt;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls T::from_bytes_noalloc(ctx,v) when T is a <a class="el" href="structmutils_1_1ByteRepresentable.html" title="A non-POD type which wishes to mark itself byte representable should extend this class. ">ByteRepresentable</a>. </p>
<p>returns raw pointer when T is a POD custom logic is implemented for some STL types. </p>

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00377">377</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="ac832c4bc18d32412c220e534ceca0f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac832c4bc18d32412c220e534ceca0f28">&#9670;&nbsp;</a></span>from_bytes_noalloc() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_pod&lt;T&gt;::value, <a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt;std::decay_t&lt;T&gt; &gt; &gt; mutils::from_bytes_noalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls T::from_bytes_noalloc(ctx,v) when T is a <a class="el" href="structmutils_1_1ByteRepresentable.html" title="A non-POD type which wishes to mark itself byte representable should extend this class. ">ByteRepresentable</a>. </p>
<p>returns raw pointer when T is a POD custom logic is implemented for some STL types. </p>

</div>
</div>
<a id="a6cccf58fb1e428e00c8046e83f5ca518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cccf58fb1e428e00c8046e83f5ca518">&#9670;&nbsp;</a></span>from_bytes_noalloc() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_pod&lt; T &gt;::value, <a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; const std::decay_t&lt; T &gt; &gt; &gt; mutils::from_bytes_noalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt;T&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00704">704</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a2ac335771f68029fb5ee34f49748beeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac335771f68029fb5ee34f49748beeb">&#9670;&nbsp;</a></span>from_bytes_noalloc() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_pod&lt;T&gt;::value, <a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt;std::decay_t&lt;T&gt; &gt; &gt; mutils::from_bytes_noalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt;T&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00696">696</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="aa2cb84f12b4ea50d904b0ce2a666595d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2cb84f12b4ea50d904b0ce2a666595d">&#9670;&nbsp;</a></span>from_bytes_noalloc() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt;type_check&lt;<a class="el" href="structmutils_1_1is__string.html">is_string</a>, T&gt; &gt; mutils::from_bytes_noalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt;T&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00747">747</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a103ad3a62e1f1c83e133eabcbf3d65db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103ad3a62e1f1c83e133eabcbf3d65db">&#9670;&nbsp;</a></span>from_bytes_noalloc() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt;type_check&lt;is_set, T&gt; &gt; mutils::from_bytes_noalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt;T&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00769">769</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a78c6ac6fab9cf86dce2fb6c2dc0f51f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c6ac6fab9cf86dce2fb6c2dc0f51f5">&#9670;&nbsp;</a></span>from_bytes_noalloc() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt;type_check&lt;<a class="el" href="structmutils_1_1is__pair.html">is_pair</a>, T&gt; &gt; mutils::from_bytes_noalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt;T&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00801">801</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="adde2cde7b86d3eea73a7be040edb7969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde2cde7b86d3eea73a7be040edb7969">&#9670;&nbsp;</a></span>from_bytes_noalloc() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt;type_check&lt;is_vector, T&gt; &gt; mutils::from_bytes_noalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt;T&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00867">867</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a3e95e6572d85eac8a59b2095582c8662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e95e6572d85eac8a59b2095582c8662">&#9670;&nbsp;</a></span>from_bytes_noalloc() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt;type_check&lt;<a class="el" href="structmutils_1_1is__map.html">is_map</a>, T&gt; &gt; mutils::from_bytes_noalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt;T&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00893">893</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a8a37a487b89fc04b74696da5269cc803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a37a487b89fc04b74696da5269cc803">&#9670;&nbsp;</a></span>from_bytes_noalloc_v() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::from_bytes_noalloc_v </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const * const&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8cpp_source.html#l00058">58</a> of file <a class="el" href="SerializationSupport_8cpp_source.html">SerializationSupport.cpp</a>.</p>

</div>
</div>
<a id="a34f15ac4d92b13ea311cf6e2946c014e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f15ac4d92b13ea311cf6e2946c014e">&#9670;&nbsp;</a></span>from_bytes_noalloc_v() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::from_bytes_noalloc_v </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname"><em>dsm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; Rest &gt; &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00935">935</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a40ddd510198109b06198421baa60b383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ddd510198109b06198421baa60b383">&#9670;&nbsp;</a></span>from_bytes_noalloc_v() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::from_bytes_noalloc_v </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname"><em>dsm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; const T &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; const Rest &gt; &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00942">942</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a2002016cd37fc94a4015cc81e0f37226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2002016cd37fc94a4015cc81e0f37226">&#9670;&nbsp;</a></span>from_bytes_noalloc_v_nc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::from_bytes_noalloc_v_nc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname"><em>dsm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemutils.html#afa3f54540dfb84b55fdd44ebf2cab964">context_ptr</a>&lt; Rest &gt; &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00926">926</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="ae27d3c4d2ac579c4ba2f689bbdbfa2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27d3c4d2ac579c4ba2f689bbdbfa2f4">&#9670;&nbsp;</a></span>from_bytes_v() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::from_bytes_v </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const * const&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8cpp_source.html#l00054">54</a> of file <a class="el" href="SerializationSupport_8cpp_source.html">SerializationSupport.cpp</a>.</p>

</div>
</div>
<a id="a2d5e93567b27ce9d2b29a4d119390c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5e93567b27ce9d2b29a4d119390c43">&#9670;&nbsp;</a></span>from_bytes_v() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::from_bytes_v </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname"><em>dsm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rest &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00916">916</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="ae6ecdecf3792422b475186265f42a15a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ecdecf3792422b475186265f42a15a">&#9670;&nbsp;</a></span>from_string() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;type_check&lt;std::is_integral, T&gt; &gt; mutils::from_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00656">656</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a0d54553e3bca7e7325cfd42d855b902c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d54553e3bca7e7325cfd42d855b902c">&#9670;&nbsp;</a></span>from_string() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;type_check&lt;std::is_floating_point, T&gt; &gt; mutils::from_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00662">662</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="aaf94e92dd45023174778ac9637aabd5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf94e92dd45023174778ac9637aabd5f">&#9670;&nbsp;</a></span>from_string() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;type_check&lt;<a class="el" href="structmutils_1_1is__string.html">is_string</a>, T&gt; &gt; mutils::from_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutils_1_1DeserializationManager.html">DeserializationManager</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00677">677</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a4d02469455d3abef84eb003370332f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d02469455d3abef84eb003370332f65">&#9670;&nbsp;</a></span>post_object() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename BR , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_pod&lt;BR&gt;::value&gt; mutils::post_object </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BR &amp;&#160;</td>
          <td class="paramname"><em>br</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In-place serialization is also sometimes possible. </p>
<p>This will take a function that expects buffers to be posted, and will post the object (potentially in multiple buffers) via repeated calls to the function </p>

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00310">310</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="aaa725535241999ca207b40ce915afdd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa725535241999ca207b40ce915afdd5">&#9670;&nbsp;</a></span>post_object() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mutils::post_object </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(char const *const, std::size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmutils_1_1ByteRepresentable.html">ByteRepresentable</a> &amp;&#160;</td>
          <td class="paramname"><em>br</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8cpp_source.html#l00042">42</a> of file <a class="el" href="SerializationSupport_8cpp_source.html">SerializationSupport.cpp</a>.</p>

</div>
</div>
<a id="a8595658650a4286eccb9bfa6ba2cdfab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8595658650a4286eccb9bfa6ba2cdfab">&#9670;&nbsp;</a></span>post_object() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mutils::post_object </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(char const *const, std::size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8cpp_source.html#l00046">46</a> of file <a class="el" href="SerializationSupport_8cpp_source.html">SerializationSupport.cpp</a>.</p>

</div>
</div>
<a id="a34609d3a9218115f434b3a0db41b12ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34609d3a9218115f434b3a0db41b12ad">&#9670;&nbsp;</a></span>post_object() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mutils::post_object </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(char const *const, std::size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; T, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>pair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00484">484</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a71c3c40f00cbae421d8f3219d1f807d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c3c40f00cbae421d8f3219d1f807d0">&#9670;&nbsp;</a></span>post_object() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mutils::post_object </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(char const *const, std::size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00498">498</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="ab6165999eb1ed1f436f8f312fee8a4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6165999eb1ed1f436f8f312fee8a4a2">&#9670;&nbsp;</a></span>post_object() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mutils::post_object </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(char const *const, std::size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a33a83762098a03c2a41d7cc59323fdac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a83762098a03c2a41d7cc59323fdac">&#9670;&nbsp;</a></span>post_object() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mutils::post_object </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(char const *const, std::size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00511">511</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a81e9ca251aad4bac4a715129268d4d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e9ca251aad4bac4a715129268d4d9d">&#9670;&nbsp;</a></span>post_object() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mutils::post_object </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(char const *const, std::size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00526">526</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a092156e791ace0b17c9a54019312516c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a092156e791ace0b17c9a54019312516c">&#9670;&nbsp;</a></span>post_object() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mutils::post_object </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(char const *const, std::size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00536">536</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a663a95782d14c5b80b669b0529a81c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663a95782d14c5b80b669b0529a81c48">&#9670;&nbsp;</a></span>post_object() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mutils::post_object </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(char const *const, std::size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00546">546</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a918911f9636af6296afa8ce7fc44d72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918911f9636af6296afa8ce7fc44d72a">&#9670;&nbsp;</a></span>post_object_helper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mutils::post_object_helper </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(char const *const, std::size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;...&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00491">491</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a60aac469a3b3f189c4a1f49b99803e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60aac469a3b3f189c4a1f49b99803e33">&#9670;&nbsp;</a></span>post_to_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(char const* const, std::size_t)&gt; mutils::post_to_buffer </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8cpp_source.html#l00035">35</a> of file <a class="el" href="SerializationSupport_8cpp_source.html">SerializationSupport.cpp</a>.</p>

</div>
</div>
<a id="accb8cc0912cf726ca32abd4464008da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb8cc0912cf726ca32abd4464008da0">&#9670;&nbsp;</a></span>to_bytes() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::to_bytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmutils_1_1ByteRepresentable.html">ByteRepresentable</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calls b.to_bytes(v) when b is a <a class="el" href="structmutils_1_1ByteRepresentable.html" title="A non-POD type which wishes to mark itself byte representable should extend this class. ">ByteRepresentable</a>; calls std::memcpy() when b is POD. </p>
<p>Custom logic is implemented for some STL types. When ubuntu gets GCC5.0 or better, this will also work if b is trivially copyable. </p>

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8cpp_source.html#l00007">7</a> of file <a class="el" href="SerializationSupport_8cpp_source.html">SerializationSupport.cpp</a>.</p>

</div>
</div>
<a id="acc01f020612459bb04fb5809ff2d10cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc01f020612459bb04fb5809ff2d10cd">&#9670;&nbsp;</a></span>to_bytes() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::to_bytes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extracts the C string (char*) equivalent to this std::string and stores it in v </p>

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8cpp_source.html#l00015">15</a> of file <a class="el" href="SerializationSupport_8cpp_source.html">SerializationSupport.cpp</a>.</p>

</div>
</div>
<a id="a18b58f9069bb55f2c99f6f17505995a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b58f9069bb55f2c99f6f17505995a7">&#9670;&nbsp;</a></span>to_bytes() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , restrict(std::is_pod&lt; T &gt;::value) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::to_bytes </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special to_bytes for POD types, which just uses memcpy. </p>

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00566">566</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a168a05db072825e5c6df02efa72ac637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168a05db072825e5c6df02efa72ac637">&#9670;&nbsp;</a></span>to_bytes() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::to_bytes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaaa69a03d0ec336623d8b9a5962c603e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa69a03d0ec336623d8b9a5962c603e">&#9670;&nbsp;</a></span>to_bytes() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::to_bytes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00576">576</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="af999a678ae4fc3437be0405d9ea1bb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af999a678ae4fc3437be0405d9ea1bb18">&#9670;&nbsp;</a></span>to_bytes() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::to_bytes </td>
          <td>(</td>
          <td class="paramtype">const std::list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00584">584</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a2d490f1e6cb1de193ab0a7aa05ee6ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d490f1e6cb1de193ab0a7aa05ee6ce3">&#9670;&nbsp;</a></span>to_bytes() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::to_bytes </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; T, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>pair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00592">592</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a1bac3fa5951650db15122286fe13f1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bac3fa5951650db15122286fe13f1a0">&#9670;&nbsp;</a></span>to_bytes() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::to_bytes </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00599">599</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="ab5e554be68e29d12bab9b44ac1dfda09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e554be68e29d12bab9b44ac1dfda09">&#9670;&nbsp;</a></span>to_bytes() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::to_bytes </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00606">606</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="af74a255f730d50b17da9540023910380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74a255f730d50b17da9540023910380">&#9670;&nbsp;</a></span>to_bytes() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::to_bytes </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00614">614</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<a id="a04efc07fef62de5e7f9f5ebe28b34fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04efc07fef62de5e7f9f5ebe28b34fa6">&#9670;&nbsp;</a></span>to_bytes_v() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::to_bytes_v </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For Serializing and Deserializing many objects at once. </p>
<p>The deserialization expects unique_ptr references; this is important! Also the buffer is at the beginning! This is important. </p>

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8cpp_source.html#l00050">50</a> of file <a class="el" href="SerializationSupport_8cpp_source.html">SerializationSupport.cpp</a>.</p>

</div>
</div>
<a id="a1576041e86f15fb3c967b422fbd22a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1576041e86f15fb3c967b422fbd22a4f">&#9670;&nbsp;</a></span>to_bytes_v() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mutils::to_bytes_v </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Rest &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00908">908</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a873b640a01cd43188b97edcf394c5213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873b640a01cd43188b97edcf394c5213">&#9670;&nbsp;</a></span>post_to_buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(char const* const, std::size_t)&gt; mutils::post_to_buffer(std::size_t &amp;index, char *dest_buf)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialization is also implemented for the following STL types: vector pair string set. </p>
<p>Constructs a buffer-consuming function that will copy its input to the provided destination buffer at the specified index. The created function can be used as an input to post_object to make post_object serialize the object to a buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The offset within dest_buf at which the function should copy inputs </td></tr>
    <tr><td class="paramname">dest_buf</td><td>The buffer that should receive bytes read by the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A function that consumes a byte buffer and writes it to dest_buf </dd></dl>

<p class="definition">Definition at line <a class="el" href="SerializationSupport_8hpp_source.html#l00476">476</a> of file <a class="el" href="SerializationSupport_8hpp_source.html">SerializationSupport.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Oct 26 2019 22:02:39 for Derecho by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
