<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Derecho: derecho Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Derecho
   &#160;<span id="projectnumber">1.2</span>
   </div>
   <div id="projectbrief">Distributed systems toolkit for RDMA</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">derecho Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacederecho_1_1gmssst"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho_1_1gmssst.html">gmssst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacederecho_1_1rpc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho_1_1rpc.html">rpc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1CallbackSet.html">CallbackSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bundles together a set of callback functions for message delivery events.  <a href="structderecho_1_1CallbackSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1CrossProductAllocator.html">CrossProductAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A shard_view_generator_t functor that creates a set of subgroups that is the "cross-product" of two subgroups, source and target.  <a href="classderecho_1_1CrossProductAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1CrossProductPolicy.html">CrossProductPolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1DefaultSubgroupAllocator.html">DefaultSubgroupAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor of type shard_view_generator_t that implements the default subgroup allocation algorithm, parameterized based on a <a class="el" href="structderecho_1_1SubgroupAllocationPolicy.html">SubgroupAllocationPolicy</a>.  <a href="classderecho_1_1DefaultSubgroupAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1derecho__exception.html">derecho_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base exception class for all exceptions raised by Derecho.  <a href="structderecho_1_1derecho__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1DerechoParams.html">DerechoParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1DerechoSST.html">DerechoSST</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The GMS and derecho_group will share the same SST for efficiency.  <a href="classderecho_1_1DerechoSST.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1empty__reference__exception.html">empty_reference_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception that means a reference-like type is "empty" (does not contain a valid object).  <a href="structderecho_1_1empty__reference__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1ExternalCaller.html">ExternalCaller</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1Group.html">Group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The top-level object for creating a Derecho group.  <a href="classderecho_1_1Group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1invalid__subgroup__exception.html">invalid_subgroup_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception that means the user made an invalid request for a subgroup handle, such as by supplying an out-of-bounds subgroup index.  <a href="structderecho_1_1invalid__subgroup__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1LockedQueue.html">LockedQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A little helper class that implements a threadsafe queue by requiring all clients to lock a mutex before accessing the queue.  <a href="classderecho_1_1LockedQueue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1LockedReference.html">LockedReference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A little helper class that wraps together a reference and a lock on a related mutex.  <a href="classderecho_1_1LockedReference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1MessageBuffer.html">MessageBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a block of memory used to store a message.  <a href="structderecho_1_1MessageBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1MulticastGroup.html">MulticastGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the low-level mechanics of tracking multicasts in a Derecho group, using RDMC to deliver messages and SST to track their arrival and stability.  <a href="classderecho_1_1MulticastGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1PersistenceManager.html">PersistenceManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classderecho_1_1PersistenceManager.html" title="PersistenceManager is responsible for persisting all the data in a group. ">PersistenceManager</a> is responsible for persisting all the data in a group.  <a href="classderecho_1_1PersistenceManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1PersistsFields.html">PersistsFields</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a marker interface for user-defined <a class="el" href="classderecho_1_1Replicated.html">Replicated</a> Objects (i.e.  <a href="classderecho_1_1PersistsFields.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1RawObject.html">RawObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type to use in the <a class="el" href="structderecho_1_1SubgroupInfo.html" title="Container for whatever information is needed to describe a Group&#39;s subgroups and shards. ">SubgroupInfo</a> maps for a subgroup that doesn't implement a <a class="el" href="classderecho_1_1Replicated.html">Replicated</a> Object.  <a href="structderecho_1_1RawObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1RawSubgroup.html">RawSubgroup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1RDMCMessage.html">RDMCMessage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1Replicated.html">Replicated</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1ReplicatedObject.html">ReplicatedObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common interface for all types of Replicated&lt;T&gt;, specifying some methods for state transfer and persistence.  <a href="classderecho_1_1ReplicatedObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1ShardAllocationPolicy.html">ShardAllocationPolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1ShardIterator.html">ShardIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1SSTMessage.html">SSTMessage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1subgroup__provisioning__exception.html">subgroup_provisioning_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception that indicates that a subgroup membership function was unable to finish executing because its enclosing <a class="el" href="classderecho_1_1Group.html" title="The top-level object for creating a Derecho group. ">Group</a> was not in a valid state.  <a href="classderecho_1_1subgroup__provisioning__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1SubgroupAllocationPolicy.html">SubgroupAllocationPolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1SubgroupInfo.html">SubgroupInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for whatever information is needed to describe a <a class="el" href="classderecho_1_1Group.html" title="The top-level object for creating a Derecho group. ">Group</a>'s subgroups and shards.  <a href="structderecho_1_1SubgroupInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1SubgroupSettings.html">SubgroupSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of settings for a single subgroup that this node is a member of.  <a href="structderecho_1_1SubgroupSettings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1SubView.html">SubView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The subset of a <a class="el" href="classderecho_1_1View.html">View</a> associated with a single shard, or a single subgroup if the subgroup is non-sharded.  <a href="classderecho_1_1SubView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1View.html">View</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1ViewManager.html">ViewManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5166c1baf8aaf072658901fa0ec4e06d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a> = uint32_t</td></tr>
<tr class="memdesc:a5166c1baf8aaf072658901fa0ec4e06d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for the internal Subgroup IDs generated by <a class="el" href="classderecho_1_1ViewManager.html">ViewManager</a>.  <a href="#a5166c1baf8aaf072658901fa0ec4e06d">More...</a><br /></td></tr>
<tr class="separator:a5166c1baf8aaf072658901fa0ec4e06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7594bd002094b1ea329f4452fbb9829b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a7594bd002094b1ea329f4452fbb9829b">message_id_t</a> = int32_t</td></tr>
<tr class="memdesc:a7594bd002094b1ea329f4452fbb9829b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a message's unique "sequence number" or index.  <a href="#a7594bd002094b1ea329f4452fbb9829b">More...</a><br /></td></tr>
<tr class="separator:a7594bd002094b1ea329f4452fbb9829b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b280cc024a2495afc8337635c38bab"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a82b280cc024a2495afc8337635c38bab">ip_addr</a> = std::string</td></tr>
<tr class="memdesc:a82b280cc024a2495afc8337635c38bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for IP addresses, currently stored as strings.  <a href="#a82b280cc024a2495afc8337635c38bab">More...</a><br /></td></tr>
<tr class="separator:a82b280cc024a2495afc8337635c38bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ec8cb782d4904ba3eaa68bcf3a9362"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#aa3ec8cb782d4904ba3eaa68bcf3a9362">node_id_t</a> = uint32_t</td></tr>
<tr class="memdesc:aa3ec8cb782d4904ba3eaa68bcf3a9362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for Node IDs in a Derecho group.  <a href="#aa3ec8cb782d4904ba3eaa68bcf3a9362">More...</a><br /></td></tr>
<tr class="separator:aa3ec8cb782d4904ba3eaa68bcf3a9362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41543bef2bcb1cfc227fb0947822ed9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#ac41543bef2bcb1cfc227fb0947822ed9">persistence_manager_make_version_func_t</a> = std::function&lt; void(const <a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a> &amp;, const persistent::version_t &amp;, const HLC &amp;)&gt;</td></tr>
<tr class="separator:ac41543bef2bcb1cfc227fb0947822ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73cc00266da2f4917322ff8dc9d1669"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#ab73cc00266da2f4917322ff8dc9d1669">persistence_manager_post_persist_func_t</a> = std::function&lt; void(const <a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a> &amp;, const persistent::version_t &amp;)&gt;</td></tr>
<tr class="separator:ab73cc00266da2f4917322ff8dc9d1669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd25e81ead51e3f21992b9321fc06e5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a1dd25e81ead51e3f21992b9321fc06e5">persistence_manager_callbacks_t</a> = std::tuple&lt; <a class="el" href="namespacederecho.html#ac41543bef2bcb1cfc227fb0947822ed9">persistence_manager_make_version_func_t</a>, <a class="el" href="namespacederecho.html#ab73cc00266da2f4917322ff8dc9d1669">persistence_manager_post_persist_func_t</a> &gt;</td></tr>
<tr class="separator:a1dd25e81ead51e3f21992b9321fc06e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55bb326016160eb730dc9fe0514c81c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa55bb326016160eb730dc9fe0514c81c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#aa55bb326016160eb730dc9fe0514c81c">replicated_index_map</a> = std::map&lt; uint32_t, <a class="el" href="classderecho_1_1Replicated.html">Replicated</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:aa55bb326016160eb730dc9fe0514c81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0445d84df5a0f1275e7efcb6a58536e4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a0445d84df5a0f1275e7efcb6a58536e4">message_callback_t</a> = std::function&lt; void(<a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a>, <a class="el" href="namespacederecho.html#aa3ec8cb782d4904ba3eaa68bcf3a9362">node_id_t</a>, <a class="el" href="namespacederecho.html#a7594bd002094b1ea329f4452fbb9829b">message_id_t</a>, char *, long long int)&gt;</td></tr>
<tr class="memdesc:a0445d84df5a0f1275e7efcb6a58536e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for the internal subgroup IDs generated by <a class="el" href="classderecho_1_1ViewManager.html">ViewManager</a>.  <a href="#a0445d84df5a0f1275e7efcb6a58536e4">More...</a><br /></td></tr>
<tr class="separator:a0445d84df5a0f1275e7efcb6a58536e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8624716823ab496a6dd95c15363067a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#ac8624716823ab496a6dd95c15363067a">persistence_callback_t</a> = std::function&lt; void(<a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a>, persistent::version_t)&gt;</td></tr>
<tr class="separator:ac8624716823ab496a6dd95c15363067a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7555b404c6d334bdc241de6bb8534c39"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a7555b404c6d334bdc241de6bb8534c39">rpc_handler_t</a> = std::function&lt; void(<a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a>, <a class="el" href="namespacederecho.html#aa3ec8cb782d4904ba3eaa68bcf3a9362">node_id_t</a>, char *, uint32_t)&gt;</td></tr>
<tr class="separator:a7555b404c6d334bdc241de6bb8534c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399961c8a9af951d5dc20f468f0e9ad0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a399961c8a9af951d5dc20f468f0e9ad0">persistence_request_t</a> = std::tuple&lt; <a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a>, persistent::version_t &gt;</td></tr>
<tr class="separator:a399961c8a9af951d5dc20f468f0e9ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae5633b492f5faf7c9f2bc514ac2d27"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ae5633b492f5faf7c9f2bc514ac2d27"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a9ae5633b492f5faf7c9f2bc514ac2d27">has_persistent_fields</a> = std::is_base_of&lt; <a class="el" href="classderecho_1_1PersistsFields.html">PersistsFields</a>, T &gt;</td></tr>
<tr class="memdesc:a9ae5633b492f5faf7c9f2bc514ac2d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template whose member field "value" will be true if type T inherits from <a class="el" href="classderecho_1_1PersistsFields.html" title="This is a marker interface for user-defined Replicated Objects (i.e. ">PersistsFields</a>, and false otherwise.  <a href="#a9ae5633b492f5faf7c9f2bc514ac2d27">More...</a><br /></td></tr>
<tr class="separator:a9ae5633b492f5faf7c9f2bc514ac2d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169d9fd2f63d82f866b27a1bc7ee2708"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a169d9fd2f63d82f866b27a1bc7ee2708"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a169d9fd2f63d82f866b27a1bc7ee2708">Factory</a> = std::function&lt; std::unique_ptr&lt; T &gt;(PersistentRegistry *)&gt;</td></tr>
<tr class="separator:a169d9fd2f63d82f866b27a1bc7ee2708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0ee73d7d0341de956f33edb2878e20"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a3b0ee73d7d0341de956f33edb2878e20">subgroup_shard_layout_t</a> = std::vector&lt; std::vector&lt; <a class="el" href="classderecho_1_1SubView.html">SubView</a> &gt; &gt;</td></tr>
<tr class="memdesc:a3b0ee73d7d0341de956f33edb2878e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data structure used to store a subgroups-and-shards layout for a single subgroup type (i.e.  <a href="#a3b0ee73d7d0341de956f33edb2878e20">More...</a><br /></td></tr>
<tr class="separator:a3b0ee73d7d0341de956f33edb2878e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8651226d31b566ef9e4029b37b9d8476"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a8651226d31b566ef9e4029b37b9d8476">shard_view_generator_t</a> = std::function&lt; <a class="el" href="namespacederecho.html#a3b0ee73d7d0341de956f33edb2878e20">subgroup_shard_layout_t</a>(const <a class="el" href="classderecho_1_1View.html">View</a> &amp;, int &amp;, bool)&gt;</td></tr>
<tr class="memdesc:a8651226d31b566ef9e4029b37b9d8476"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a lambda function that generates subgroup and shard views for a specific subgroup type.  <a href="#a8651226d31b566ef9e4029b37b9d8476">More...</a><br /></td></tr>
<tr class="separator:a8651226d31b566ef9e4029b37b9d8476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b5717079bf92d1ec04efa8660a327e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#aa0b5717079bf92d1ec04efa8660a327e">lock_guard_t</a> = std::lock_guard&lt; std::mutex &gt;</td></tr>
<tr class="separator:aa0b5717079bf92d1ec04efa8660a327e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c56618eccc62191c8504856cfd9d18"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#ae6c56618eccc62191c8504856cfd9d18">unique_lock_t</a> = std::unique_lock&lt; std::mutex &gt;</td></tr>
<tr class="separator:ae6c56618eccc62191c8504856cfd9d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2cd00140eaa031b4056c2c51caef18"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#aff2cd00140eaa031b4056c2c51caef18">shared_lock_t</a> = std::shared_lock&lt; std::shared_timed_mutex &gt;</td></tr>
<tr class="separator:aff2cd00140eaa031b4056c2c51caef18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d358a67fa805be8a898a6e19f3e225"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab9d358a67fa805be8a898a6e19f3e225"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#ab9d358a67fa805be8a898a6e19f3e225">SharedLockedReference</a> = <a class="el" href="classderecho_1_1LockedReference.html">LockedReference</a>&lt; std::shared_lock&lt; std::shared_timed_mutex &gt;, T &gt;</td></tr>
<tr class="separator:ab9d358a67fa805be8a898a6e19f3e225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8847e67ac70cd55aa5114fc3294aa326"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a8847e67ac70cd55aa5114fc3294aa326">view_upcall_t</a> = std::function&lt; void(const <a class="el" href="classderecho_1_1View.html">View</a> &amp;)&gt;</td></tr>
<tr class="separator:a8847e67ac70cd55aa5114fc3294aa326"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1fb14b9518cde9d5f222d1d6039b8bdc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a1fb14b9518cde9d5f222d1d6039b8bdc">Mode</a> { <a class="el" href="namespacederecho.html#a1fb14b9518cde9d5f222d1d6039b8bdcaabc458a817b34b4750413b587f536ac0">Mode::ORDERED</a>, 
<a class="el" href="namespacederecho.html#a1fb14b9518cde9d5f222d1d6039b8bdca6caf8ac543ee5994b1ab98021bba1173">Mode::UNORDERED</a>
 }</td></tr>
<tr class="separator:a1fb14b9518cde9d5f222d1d6039b8bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7a4ed687e994d00b37422107ffc38204"><td class="memTemplParams" colspan="2">template&lt;typename MapType &gt; </td></tr>
<tr class="memitem:a7a4ed687e994d00b37422107ffc38204"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a7a4ed687e994d00b37422107ffc38204">kind_map_builder</a> (MapType &amp;)</td></tr>
<tr class="separator:a7a4ed687e994d00b37422107ffc38204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da328941ec7107e38b82de353ab326a"><td class="memTemplParams" colspan="2">template&lt;typename MapType , typename FirstType , typename... RestTypes&gt; </td></tr>
<tr class="memitem:a2da328941ec7107e38b82de353ab326a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a2da328941ec7107e38b82de353ab326a">kind_map_builder</a> (MapType &amp;map, <a class="el" href="namespacederecho.html#a169d9fd2f63d82f866b27a1bc7ee2708">Factory</a>&lt; FirstType &gt; curr_factory, <a class="el" href="namespacederecho.html#a169d9fd2f63d82f866b27a1bc7ee2708">Factory</a>&lt; RestTypes &gt;... rest_factories)</td></tr>
<tr class="memdesc:a2da328941ec7107e38b82de353ab326a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual implementation of make_kind_map; needs to be a separate function because the only way to build a KindMap is with a void mutator function.  <a href="#a2da328941ec7107e38b82de353ab326a">More...</a><br /></td></tr>
<tr class="separator:a2da328941ec7107e38b82de353ab326a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ad962d14dcfbe9f3066656742b2552"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a41ad962d14dcfbe9f3066656742b2552"><td class="memTemplItemLeft" align="right" valign="top">mutils::KindMap&lt; <a class="el" href="namespacederecho.html#a169d9fd2f63d82f866b27a1bc7ee2708">Factory</a>, Types... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a41ad962d14dcfbe9f3066656742b2552">make_kind_map</a> (<a class="el" href="namespacederecho.html#a169d9fd2f63d82f866b27a1bc7ee2708">Factory</a>&lt; Types &gt;... factories)</td></tr>
<tr class="memdesc:a41ad962d14dcfbe9f3066656742b2552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a KindMap&lt;Factory, Types...&gt; from a list of factories of those types.  <a href="#a41ad962d14dcfbe9f3066656742b2552">More...</a><br /></td></tr>
<tr class="separator:a41ad962d14dcfbe9f3066656742b2552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101760596625ad156d376a886a24a86a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a101760596625ad156d376a886a24a86a"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a101760596625ad156d376a886a24a86a">functional_insert</a> (std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a101760596625ad156d376a886a24a86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts set b into set a and returns the modified a.  <a href="#a101760596625ad156d376a886a24a86a">More...</a><br /></td></tr>
<tr class="separator:a101760596625ad156d376a886a24a86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6323c39d344380e5859dd390856c7ea4"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a6323c39d344380e5859dd390856c7ea4"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a6323c39d344380e5859dd390856c7ea4">index_of</a> (T container, U elem)</td></tr>
<tr class="memdesc:a6323c39d344380e5859dd390856c7ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to find the index of an element in a container.  <a href="#a6323c39d344380e5859dd390856c7ea4">More...</a><br /></td></tr>
<tr class="separator:a6323c39d344380e5859dd390856c7ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136390448e35fec19f72933c9bcdef80"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a136390448e35fec19f72933c9bcdef80">__attribute__</a> ((__packed__)) header</td></tr>
<tr class="separator:a136390448e35fec19f72933c9bcdef80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1bc9c5ac5e6c171fbb07a6c745d230"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#acc1bc9c5ac5e6c171fbb07a6c745d230">print_subgroup_layout</a> (const <a class="el" href="namespacederecho.html#a3b0ee73d7d0341de956f33edb2878e20">subgroup_shard_layout_t</a> &amp;layout)</td></tr>
<tr class="memdesc:acc1bc9c5ac5e6c171fbb07a6c745d230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the membership of a subgroup/shard layout to stdout.  <a href="#acc1bc9c5ac5e6c171fbb07a6c745d230">More...</a><br /></td></tr>
<tr class="separator:acc1bc9c5ac5e6c171fbb07a6c745d230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7e09a1f5bcd4328c061fd3ba66c81b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a7c7e09a1f5bcd4328c061fd3ba66c81b">test_provision_subgroups</a> (const <a class="el" href="structderecho_1_1SubgroupInfo.html">SubgroupInfo</a> &amp;subgroup_info, const std::unique_ptr&lt; <a class="el" href="classderecho_1_1View.html">View</a> &gt; &amp;prev_view, <a class="el" href="classderecho_1_1View.html">View</a> &amp;curr_view)</td></tr>
<tr class="memdesc:a7c7e09a1f5bcd4328c061fd3ba66c81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the same logic as <a class="el" href="classderecho_1_1ViewManager.html#a58d492d4c591f1dc00ccc0c1904f89f0" title="Initializes the current View with subgroup information, and creates the subgroup-settings map that Mu...">ViewManager::make_subgroup_maps()</a>, only without actually saving the subgroup_to_x maps.  <a href="#a7c7e09a1f5bcd4328c061fd3ba66c81b">More...</a><br /></td></tr>
<tr class="separator:a7c7e09a1f5bcd4328c061fd3ba66c81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade41f7c45f3d0d8dca45a575448c7169"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classderecho_1_1View.html">View</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#ade41f7c45f3d0d8dca45a575448c7169">make_next_view</a> (const <a class="el" href="classderecho_1_1View.html">View</a> &amp;curr_view, const std::set&lt; int &gt; &amp;leave_ranks, const std::vector&lt; <a class="el" href="namespacederecho.html#aa3ec8cb782d4904ba3eaa68bcf3a9362">node_id_t</a> &gt; &amp;joiner_ids, const std::vector&lt; <a class="el" href="namespacederecho.html#a82b280cc024a2495afc8337635c38bab">ip_addr</a> &gt; &amp;joiner_ips)</td></tr>
<tr class="memdesc:ade41f7c45f3d0d8dca45a575448c7169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the next <a class="el" href="classderecho_1_1View.html">View</a> given the current <a class="el" href="classderecho_1_1View.html">View</a> and the set of failures and joins.  <a href="#ade41f7c45f3d0d8dca45a575448c7169">More...</a><br /></td></tr>
<tr class="separator:ade41f7c45f3d0d8dca45a575448c7169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae7da5e3f17c51c3531d00a53fbc2cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacederecho.html#a3b0ee73d7d0341de956f33edb2878e20">subgroup_shard_layout_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a1ae7da5e3f17c51c3531d00a53fbc2cc">one_subgroup_entire_view</a> (const <a class="el" href="classderecho_1_1View.html">View</a> &amp;curr_view, int &amp;next_unassigned_rank, bool previous_was_successful)</td></tr>
<tr class="separator:a1ae7da5e3f17c51c3531d00a53fbc2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e93d0c16376de991bd8c77092d706c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacederecho.html#a3b0ee73d7d0341de956f33edb2878e20">subgroup_shard_layout_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#af3e93d0c16376de991bd8c77092d706c">one_subgroup_entire_view_raw</a> (const <a class="el" href="classderecho_1_1View.html">View</a> &amp;curr_view, int &amp;next_unassigned_rank, bool previous_was_successful)</td></tr>
<tr class="separator:af3e93d0c16376de991bd8c77092d706c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0243871e8d5df1613d3fdde7a34af9f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structderecho_1_1ShardAllocationPolicy.html">ShardAllocationPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a0243871e8d5df1613d3fdde7a34af9f7">even_sharding_policy</a> (int num_shards, int nodes_per_shard)</td></tr>
<tr class="memdesc:a0243871e8d5df1613d3fdde7a34af9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="structderecho_1_1ShardAllocationPolicy.html">ShardAllocationPolicy</a> that specifies num_shards shards with the same number of nodes in each shard.  <a href="#a0243871e8d5df1613d3fdde7a34af9f7">More...</a><br /></td></tr>
<tr class="separator:a0243871e8d5df1613d3fdde7a34af9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2cfda95d10697c3ce56bd9a041579cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structderecho_1_1ShardAllocationPolicy.html">ShardAllocationPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#ab2cfda95d10697c3ce56bd9a041579cc">raw_even_sharding_policy</a> (int num_shards, int nodes_per_shard)</td></tr>
<tr class="memdesc:ab2cfda95d10697c3ce56bd9a041579cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="structderecho_1_1ShardAllocationPolicy.html">ShardAllocationPolicy</a> that specifies num_shards shards with the same number of nodes in each shard, and every shard running in "raw" delivery mode.  <a href="#ab2cfda95d10697c3ce56bd9a041579cc">More...</a><br /></td></tr>
<tr class="separator:ab2cfda95d10697c3ce56bd9a041579cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea7b838acf6fc6bf2e54dd886c2cb7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structderecho_1_1ShardAllocationPolicy.html">ShardAllocationPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#afea7b838acf6fc6bf2e54dd886c2cb7b">custom_shards_policy</a> (const std::vector&lt; int &gt; &amp;num_nodes_by_shard, const std::vector&lt; <a class="el" href="namespacederecho.html#a1fb14b9518cde9d5f222d1d6039b8bdc">Mode</a> &gt; &amp;delivery_modes_by_shard)</td></tr>
<tr class="memdesc:afea7b838acf6fc6bf2e54dd886c2cb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="structderecho_1_1ShardAllocationPolicy.html">ShardAllocationPolicy</a> for a subgroup that has a different number of members in each shard, and possibly has each shard in a different delivery mode.  <a href="#afea7b838acf6fc6bf2e54dd886c2cb7b">More...</a><br /></td></tr>
<tr class="separator:afea7b838acf6fc6bf2e54dd886c2cb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8bf92a5d64fa9fb186b9bc71c79ece"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structderecho_1_1SubgroupAllocationPolicy.html">SubgroupAllocationPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a7e8bf92a5d64fa9fb186b9bc71c79ece">one_subgroup_policy</a> (const <a class="el" href="structderecho_1_1ShardAllocationPolicy.html">ShardAllocationPolicy</a> &amp;policy)</td></tr>
<tr class="memdesc:a7e8bf92a5d64fa9fb186b9bc71c79ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="structderecho_1_1SubgroupAllocationPolicy.html">SubgroupAllocationPolicy</a> for a replicated type that only has a single subgroup.  <a href="#a7e8bf92a5d64fa9fb186b9bc71c79ece">More...</a><br /></td></tr>
<tr class="separator:a7e8bf92a5d64fa9fb186b9bc71c79ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f529cba0c6b56c083b5044113b13e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structderecho_1_1SubgroupAllocationPolicy.html">SubgroupAllocationPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#ab4f529cba0c6b56c083b5044113b13e3">identical_subgroups_policy</a> (int num_subgroups, const <a class="el" href="structderecho_1_1ShardAllocationPolicy.html">ShardAllocationPolicy</a> &amp;subgroup_policy)</td></tr>
<tr class="memdesc:ab4f529cba0c6b56c083b5044113b13e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="structderecho_1_1SubgroupAllocationPolicy.html">SubgroupAllocationPolicy</a> for a replicated type that needs n subgroups with identical sharding policies.  <a href="#ab4f529cba0c6b56c083b5044113b13e3">More...</a><br /></td></tr>
<tr class="separator:ab4f529cba0c6b56c083b5044113b13e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fb22ba9a62f85a43c2412a786da630"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a22fb22ba9a62f85a43c2412a786da630"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a22fb22ba9a62f85a43c2412a786da630">deep_pointer_copy</a> (const std::unique_ptr&lt; T &gt; &amp;to_copy)</td></tr>
<tr class="memdesc:a22fb22ba9a62f85a43c2412a786da630"><td class="mdescLeft">&#160;</td><td class="mdescRight">A copy constructor for objects owned by unique_ptr.  <a href="#a22fb22ba9a62f85a43c2412a786da630">More...</a><br /></td></tr>
<tr class="separator:a22fb22ba9a62f85a43c2412a786da630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff5fa530d9a8219fc5c5dd69a7c89a8"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a1ff5fa530d9a8219fc5c5dd69a7c89a8"><td class="memTemplItemLeft" align="right" valign="top">std::list&lt; K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a1ff5fa530d9a8219fc5c5dd69a7c89a8">keys_as_list</a> (const std::map&lt; K, V &gt; &amp;map)</td></tr>
<tr class="memdesc:a1ff5fa530d9a8219fc5c5dd69a7c89a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a std::list of the keys in a std::map, in the same order as they appear in the std::map.  <a href="#a1ff5fa530d9a8219fc5c5dd69a7c89a8">More...</a><br /></td></tr>
<tr class="separator:a1ff5fa530d9a8219fc5c5dd69a7c89a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519d9262b85ce675c9b509593d3d6b1b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classderecho_1_1View.html">View</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a519d9262b85ce675c9b509593d3d6b1b">load_view</a> (const std::string &amp;view_file_name)</td></tr>
<tr class="memdesc:a519d9262b85ce675c9b509593d3d6b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom implementation of load_object for Views.  <a href="#a519d9262b85ce675c9b509593d3d6b1b">More...</a><br /></td></tr>
<tr class="separator:a519d9262b85ce675c9b509593d3d6b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02bbe8513bf93a849335511e0a0e348"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#ae02bbe8513bf93a849335511e0a0e348">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="classderecho_1_1View.html">View</a> &amp;view)</td></tr>
<tr class="memdesc:ae02bbe8513bf93a849335511e0a0e348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a plaintext representation of the <a class="el" href="classderecho_1_1View.html">View</a> to an output stream.  <a href="#ae02bbe8513bf93a849335511e0a0e348">More...</a><br /></td></tr>
<tr class="separator:ae02bbe8513bf93a849335511e0a0e348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24795ddb9bbf45601d93e02fab4b246"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classderecho_1_1View.html">View</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#ad24795ddb9bbf45601d93e02fab4b246">parse_view</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:ad24795ddb9bbf45601d93e02fab4b246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the plaintext representation created by operator&lt;&lt; and modifies the <a class="el" href="classderecho_1_1View.html">View</a> argument to contain the view it represents.  <a href="#ad24795ddb9bbf45601d93e02fab4b246">More...</a><br /></td></tr>
<tr class="separator:ad24795ddb9bbf45601d93e02fab4b246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9f13b79bd4400e58b85629b9c97f13"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada9f13b79bd4400e58b85629b9c97f13"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#ada9f13b79bd4400e58b85629b9c97f13">functional_append</a> (const std::vector&lt; T &gt; &amp;original, const T &amp;item)</td></tr>
<tr class="memdesc:ada9f13b79bd4400e58b85629b9c97f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base case for functional_append, with one argument.  <a href="#ada9f13b79bd4400e58b85629b9c97f13">More...</a><br /></td></tr>
<tr class="separator:ada9f13b79bd4400e58b85629b9c97f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8638b3b0dab113f03fe666ae15653f01"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... RestArgs&gt; </td></tr>
<tr class="memitem:a8638b3b0dab113f03fe666ae15653f01"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a8638b3b0dab113f03fe666ae15653f01">functional_append</a> (const std::vector&lt; T &gt; &amp;original, const T &amp;first_item, RestArgs... rest_items)</td></tr>
<tr class="memdesc:a8638b3b0dab113f03fe666ae15653f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new std::vector value that is equal to the parameter std::vector with the rest of the arguments appended.  <a href="#a8638b3b0dab113f03fe666ae15653f01">More...</a><br /></td></tr>
<tr class="separator:a8638b3b0dab113f03fe666ae15653f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a169d9fd2f63d82f866b27a1bc7ee2708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169d9fd2f63d82f866b27a1bc7ee2708">&#9670;&nbsp;</a></span>Factory</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a169d9fd2f63d82f866b27a1bc7ee2708">derecho::Factory</a> = typedef std::function&lt;std::unique_ptr&lt;T&gt;(PersistentRegistry*)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="replicated_8h_source.html#l00048">48</a> of file <a class="el" href="replicated_8h_source.html">replicated.h</a>.</p>

</div>
</div>
<a id="a9ae5633b492f5faf7c9f2bc514ac2d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae5633b492f5faf7c9f2bc514ac2d27">&#9670;&nbsp;</a></span>has_persistent_fields</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a9ae5633b492f5faf7c9f2bc514ac2d27">derecho::has_persistent_fields</a> = typedef std::is_base_of&lt;<a class="el" href="classderecho_1_1PersistsFields.html">PersistsFields</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A template whose member field "value" will be true if type T inherits from <a class="el" href="classderecho_1_1PersistsFields.html" title="This is a marker interface for user-defined Replicated Objects (i.e. ">PersistsFields</a>, and false otherwise. </p>
<p>Just a convenient specialization of std::is_base_of. </p>

<p class="definition">Definition at line <a class="el" href="replicated_8h_source.html#l00043">43</a> of file <a class="el" href="replicated_8h_source.html">replicated.h</a>.</p>

</div>
</div>
<a id="a82b280cc024a2495afc8337635c38bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b280cc024a2495afc8337635c38bab">&#9670;&nbsp;</a></span>ip_addr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a82b280cc024a2495afc8337635c38bab">derecho::ip_addr</a> = typedef std::string</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for IP addresses, currently stored as strings. </p>

<p class="definition">Definition at line <a class="el" href="derecho__internal_8h_source.html#l00025">25</a> of file <a class="el" href="derecho__internal_8h_source.html">derecho_internal.h</a>.</p>

</div>
</div>
<a id="aa0b5717079bf92d1ec04efa8660a327e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b5717079bf92d1ec04efa8660a327e">&#9670;&nbsp;</a></span>lock_guard_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#aa0b5717079bf92d1ec04efa8660a327e">derecho::lock_guard_t</a> = typedef std::lock_guard&lt;std::mutex&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="view__manager_8cpp_source.html#l00015">15</a> of file <a class="el" href="view__manager_8cpp_source.html">view_manager.cpp</a>.</p>

</div>
</div>
<a id="a0445d84df5a0f1275e7efcb6a58536e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0445d84df5a0f1275e7efcb6a58536e4">&#9670;&nbsp;</a></span>message_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a0445d84df5a0f1275e7efcb6a58536e4">derecho::message_callback_t</a> = typedef std::function&lt;void(<a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a>, <a class="el" href="namespacederecho.html#aa3ec8cb782d4904ba3eaa68bcf3a9362">node_id_t</a>, <a class="el" href="namespacederecho.html#a7594bd002094b1ea329f4452fbb9829b">message_id_t</a>, char*, long long int)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for the internal subgroup IDs generated by <a class="el" href="classderecho_1_1ViewManager.html">ViewManager</a>. </p>
<p>Alias for the type of std::function that is used for message delivery event callbacks. </p>

<p class="definition">Definition at line <a class="el" href="multicast__group_8h_source.html#l00038">38</a> of file <a class="el" href="multicast__group_8h_source.html">multicast_group.h</a>.</p>

</div>
</div>
<a id="a7594bd002094b1ea329f4452fbb9829b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7594bd002094b1ea329f4452fbb9829b">&#9670;&nbsp;</a></span>message_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a7594bd002094b1ea329f4452fbb9829b">derecho::message_id_t</a> = typedef int32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for a message's unique "sequence number" or index. </p>
<p>This allows us to change exactly which numeric type we use to store it. </p>

<p class="definition">Definition at line <a class="el" href="derecho__internal_8h_source.html#l00023">23</a> of file <a class="el" href="derecho__internal_8h_source.html">derecho_internal.h</a>.</p>

</div>
</div>
<a id="aa3ec8cb782d4904ba3eaa68bcf3a9362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ec8cb782d4904ba3eaa68bcf3a9362">&#9670;&nbsp;</a></span>node_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#aa3ec8cb782d4904ba3eaa68bcf3a9362">derecho::node_id_t</a> = typedef uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for Node IDs in a Derecho group. </p>

<p class="definition">Definition at line <a class="el" href="derecho__internal_8h_source.html#l00027">27</a> of file <a class="el" href="derecho__internal_8h_source.html">derecho_internal.h</a>.</p>

</div>
</div>
<a id="ac8624716823ab496a6dd95c15363067a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8624716823ab496a6dd95c15363067a">&#9670;&nbsp;</a></span>persistence_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#ac8624716823ab496a6dd95c15363067a">derecho::persistence_callback_t</a> = typedef std::function&lt;void(<a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a>, persistent::version_t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="multicast__group_8h_source.html#l00039">39</a> of file <a class="el" href="multicast__group_8h_source.html">multicast_group.h</a>.</p>

</div>
</div>
<a id="a1dd25e81ead51e3f21992b9321fc06e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd25e81ead51e3f21992b9321fc06e5">&#9670;&nbsp;</a></span>persistence_manager_callbacks_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a1dd25e81ead51e3f21992b9321fc06e5">derecho::persistence_manager_callbacks_t</a> = typedef std::tuple&lt;<a class="el" href="namespacederecho.html#ac41543bef2bcb1cfc227fb0947822ed9">persistence_manager_make_version_func_t</a>, <a class="el" href="namespacederecho.html#ab73cc00266da2f4917322ff8dc9d1669">persistence_manager_post_persist_func_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="derecho__internal_8h_source.html#l00037">37</a> of file <a class="el" href="derecho__internal_8h_source.html">derecho_internal.h</a>.</p>

</div>
</div>
<a id="ac41543bef2bcb1cfc227fb0947822ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41543bef2bcb1cfc227fb0947822ed9">&#9670;&nbsp;</a></span>persistence_manager_make_version_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#ac41543bef2bcb1cfc227fb0947822ed9">derecho::persistence_manager_make_version_func_t</a> = typedef std::function&lt;void( const <a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a> &amp;, const persistent::version_t &amp;, const HLC &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="derecho__internal_8h_source.html#l00033">33</a> of file <a class="el" href="derecho__internal_8h_source.html">derecho_internal.h</a>.</p>

</div>
</div>
<a id="ab73cc00266da2f4917322ff8dc9d1669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73cc00266da2f4917322ff8dc9d1669">&#9670;&nbsp;</a></span>persistence_manager_post_persist_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#ab73cc00266da2f4917322ff8dc9d1669">derecho::persistence_manager_post_persist_func_t</a> = typedef std::function&lt;void( const <a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a> &amp;, const persistent::version_t &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="derecho__internal_8h_source.html#l00036">36</a> of file <a class="el" href="derecho__internal_8h_source.html">derecho_internal.h</a>.</p>

</div>
</div>
<a id="a399961c8a9af951d5dc20f468f0e9ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399961c8a9af951d5dc20f468f0e9ad0">&#9670;&nbsp;</a></span>persistence_request_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a399961c8a9af951d5dc20f468f0e9ad0">derecho::persistence_request_t</a> = typedef std::tuple&lt;<a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a>, persistent::version_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="persistence__manager_8h_source.html#l00027">27</a> of file <a class="el" href="persistence__manager_8h_source.html">persistence_manager.h</a>.</p>

</div>
</div>
<a id="aa55bb326016160eb730dc9fe0514c81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55bb326016160eb730dc9fe0514c81c">&#9670;&nbsp;</a></span>replicated_index_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#aa55bb326016160eb730dc9fe0514c81c">derecho::replicated_index_map</a> = typedef std::map&lt;uint32_t, <a class="el" href="classderecho_1_1Replicated.html">Replicated</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="group_8h_source.html#l00036">36</a> of file <a class="el" href="group_8h_source.html">group.h</a>.</p>

</div>
</div>
<a id="a7555b404c6d334bdc241de6bb8534c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7555b404c6d334bdc241de6bb8534c39">&#9670;&nbsp;</a></span>rpc_handler_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a7555b404c6d334bdc241de6bb8534c39">derecho::rpc_handler_t</a> = typedef std::function&lt;void(<a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a>, <a class="el" href="namespacederecho.html#aa3ec8cb782d4904ba3eaa68bcf3a9362">node_id_t</a>, char*, uint32_t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="multicast__group_8h_source.html#l00040">40</a> of file <a class="el" href="multicast__group_8h_source.html">multicast_group.h</a>.</p>

</div>
</div>
<a id="a8651226d31b566ef9e4029b37b9d8476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8651226d31b566ef9e4029b37b9d8476">&#9670;&nbsp;</a></span>shard_view_generator_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a8651226d31b566ef9e4029b37b9d8476">derecho::shard_view_generator_t</a> = typedef std::function&lt;<a class="el" href="namespacederecho.html#a3b0ee73d7d0341de956f33edb2878e20">subgroup_shard_layout_t</a>(const <a class="el" href="classderecho_1_1View.html">View</a>&amp;, int&amp;, bool)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a lambda function that generates subgroup and shard views for a specific subgroup type. </p>
<p>This is a function that takes the current <a class="el" href="classderecho_1_1View.html">View</a> as input and outputs a vector-of-vectors representing subgroups and shards. </p>

<p class="definition">Definition at line <a class="el" href="subgroup__info_8h_source.html#l00052">52</a> of file <a class="el" href="subgroup__info_8h_source.html">subgroup_info.h</a>.</p>

</div>
</div>
<a id="aff2cd00140eaa031b4056c2c51caef18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2cd00140eaa031b4056c2c51caef18">&#9670;&nbsp;</a></span>shared_lock_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#aff2cd00140eaa031b4056c2c51caef18">derecho::shared_lock_t</a> = typedef std::shared_lock&lt;std::shared_timed_mutex&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="view__manager_8cpp_source.html#l00017">17</a> of file <a class="el" href="view__manager_8cpp_source.html">view_manager.cpp</a>.</p>

</div>
</div>
<a id="ab9d358a67fa805be8a898a6e19f3e225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d358a67fa805be8a898a6e19f3e225">&#9670;&nbsp;</a></span>SharedLockedReference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#ab9d358a67fa805be8a898a6e19f3e225">derecho::SharedLockedReference</a> = typedef <a class="el" href="classderecho_1_1LockedReference.html">LockedReference</a>&lt;std::shared_lock&lt;std::shared_timed_mutex&gt;, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="view__manager_8h_source.html#l00063">63</a> of file <a class="el" href="view__manager_8h_source.html">view_manager.h</a>.</p>

</div>
</div>
<a id="a5166c1baf8aaf072658901fa0ec4e06d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5166c1baf8aaf072658901fa0ec4e06d">&#9670;&nbsp;</a></span>subgroup_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">derecho::subgroup_id_t</a> = typedef uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for the internal Subgroup IDs generated by <a class="el" href="classderecho_1_1ViewManager.html">ViewManager</a>. </p>
<p>This allows us to change exactly which numeric type we use to store it. </p>

<p class="definition">Definition at line <a class="el" href="derecho__internal_8h_source.html#l00020">20</a> of file <a class="el" href="derecho__internal_8h_source.html">derecho_internal.h</a>.</p>

</div>
</div>
<a id="a3b0ee73d7d0341de956f33edb2878e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0ee73d7d0341de956f33edb2878e20">&#9670;&nbsp;</a></span>subgroup_shard_layout_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a3b0ee73d7d0341de956f33edb2878e20">derecho::subgroup_shard_layout_t</a> = typedef std::vector&lt;std::vector&lt;<a class="el" href="classderecho_1_1SubView.html">SubView</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The data structure used to store a subgroups-and-shards layout for a single subgroup type (i.e. </p>
<p><a class="el" href="classderecho_1_1Replicated.html">Replicated</a> Object type). The outer vector represents subgroups of the same type, and the inner vector represents shards of each subgroup, so the vectors map subgroup index -&gt; shard index -&gt; sub-view of that shard. </p>

<p class="definition">Definition at line <a class="el" href="subgroup__info_8h_source.html#l00047">47</a> of file <a class="el" href="subgroup__info_8h_source.html">subgroup_info.h</a>.</p>

</div>
</div>
<a id="ae6c56618eccc62191c8504856cfd9d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c56618eccc62191c8504856cfd9d18">&#9670;&nbsp;</a></span>unique_lock_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#ae6c56618eccc62191c8504856cfd9d18">derecho::unique_lock_t</a> = typedef std::unique_lock&lt;std::mutex&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="view__manager_8cpp_source.html#l00016">16</a> of file <a class="el" href="view__manager_8cpp_source.html">view_manager.cpp</a>.</p>

</div>
</div>
<a id="a8847e67ac70cd55aa5114fc3294aa326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8847e67ac70cd55aa5114fc3294aa326">&#9670;&nbsp;</a></span>view_upcall_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a8847e67ac70cd55aa5114fc3294aa326">derecho::view_upcall_t</a> = typedef std::function&lt;void(const <a class="el" href="classderecho_1_1View.html">View</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="view__manager_8h_source.html#l00065">65</a> of file <a class="el" href="view__manager_8h_source.html">view_manager.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a1fb14b9518cde9d5f222d1d6039b8bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb14b9518cde9d5f222d1d6039b8bdc">&#9670;&nbsp;</a></span>Mode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacederecho.html#a1fb14b9518cde9d5f222d1d6039b8bdc">derecho::Mode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1fb14b9518cde9d5f222d1d6039b8bdcaabc458a817b34b4750413b587f536ac0"></a>ORDERED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1fb14b9518cde9d5f222d1d6039b8bdca6caf8ac543ee5994b1ab98021bba1173"></a>UNORDERED&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="derecho__modes_8h_source.html#l00004">4</a> of file <a class="el" href="derecho__modes_8h_source.html">derecho_modes.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a136390448e35fec19f72933c9bcdef80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136390448e35fec19f72933c9bcdef80">&#9670;&nbsp;</a></span>__attribute__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct derecho::__attribute__ </td>
          <td>(</td>
          <td class="paramtype">(__packed__)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="multicast__group_8h_source.html#l00078">78</a> of file <a class="el" href="multicast__group_8h_source.html">multicast_group.h</a>.</p>

</div>
</div>
<a id="afea7b838acf6fc6bf2e54dd886c2cb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea7b838acf6fc6bf2e54dd886c2cb7b">&#9670;&nbsp;</a></span>custom_shards_policy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structderecho_1_1ShardAllocationPolicy.html">ShardAllocationPolicy</a> derecho::custom_shards_policy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>num_nodes_by_shard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacederecho.html#a1fb14b9518cde9d5f222d1d6039b8bdc">Mode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>delivery_modes_by_shard</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="structderecho_1_1ShardAllocationPolicy.html">ShardAllocationPolicy</a> for a subgroup that has a different number of members in each shard, and possibly has each shard in a different delivery mode. </p>
<p>Note that the two parameter vectors must be the same length. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_nodes_by_shard</td><td>A vector specifying how many nodes should be in each shard; the ith shard will have num_nodes_by_shard[i] members. </td></tr>
    <tr><td class="paramname">delivery_modes_by_shard</td><td>A vector specifying the delivery mode (Raw or Ordered) for each shard, in the same order as the other vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structderecho_1_1ShardAllocationPolicy.html">ShardAllocationPolicy</a> that specifies these shard sizes and modes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subgroup__functions_8cpp_source.html#l00037">37</a> of file <a class="el" href="subgroup__functions_8cpp_source.html">subgroup_functions.cpp</a>.</p>

</div>
</div>
<a id="a22fb22ba9a62f85a43c2412a786da630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22fb22ba9a62f85a43c2412a786da630">&#9670;&nbsp;</a></span>deep_pointer_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;T&gt; derecho::deep_pointer_copy </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>to_copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A copy constructor for objects owned by unique_ptr. </p>
<p>Does the obvious thing and invokes the copy constructor of the object being pointed to, or returns nullptr if the unique_ptr is empty. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_copy</td><td>A unique_ptr to the object to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new object in a new unique_ptr that is a copy of the old object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subgroup__functions_8h_source.html#l00025">25</a> of file <a class="el" href="subgroup__functions_8h_source.html">subgroup_functions.h</a>.</p>

</div>
</div>
<a id="a0243871e8d5df1613d3fdde7a34af9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0243871e8d5df1613d3fdde7a34af9f7">&#9670;&nbsp;</a></span>even_sharding_policy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structderecho_1_1ShardAllocationPolicy.html">ShardAllocationPolicy</a> derecho::even_sharding_policy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_shards</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodes_per_shard</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="structderecho_1_1ShardAllocationPolicy.html">ShardAllocationPolicy</a> that specifies num_shards shards with the same number of nodes in each shard. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_shards</td><td>The number of shards to request in this policy. </td></tr>
    <tr><td class="paramname">nodes_per_shard</td><td>The number of nodes per shard to request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structderecho_1_1ShardAllocationPolicy.html">ShardAllocationPolicy</a> value with these parameters. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subgroup__functions_8cpp_source.html#l00029">29</a> of file <a class="el" href="subgroup__functions_8cpp_source.html">subgroup_functions.cpp</a>.</p>

</div>
</div>
<a id="ada9f13b79bd4400e58b85629b9c97f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9f13b79bd4400e58b85629b9c97f13">&#9670;&nbsp;</a></span>functional_append() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; derecho::functional_append </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base case for functional_append, with one argument. </p>

<p class="definition">Definition at line <a class="el" href="view__manager_8h_source.html#l00426">426</a> of file <a class="el" href="view__manager_8h_source.html">view_manager.h</a>.</p>

</div>
</div>
<a id="a8638b3b0dab113f03fe666ae15653f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8638b3b0dab113f03fe666ae15653f01">&#9670;&nbsp;</a></span>functional_append() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... RestArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; derecho::functional_append </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>first_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestArgs...&#160;</td>
          <td class="paramname"><em>rest_items</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new std::vector value that is equal to the parameter std::vector with the rest of the arguments appended. </p>
<p>Adds some missing functionality to std::vector: the ability to append to a const vector without taking a several-line detour to call the void emplace_back() method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>The vector that should be the prefix of the new vector </td></tr>
    <tr><td class="paramname">first_item</td><td>The first element to append to the original vector </td></tr>
    <tr><td class="paramname">rest_items</td><td>The rest of the elements to append to the original vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new vector (by value), containing a copy of original plus all the elements given as arguments. </dd></dl>

<p class="definition">Definition at line <a class="el" href="view__manager_8h_source.html#l00444">444</a> of file <a class="el" href="view__manager_8h_source.html">view_manager.h</a>.</p>

</div>
</div>
<a id="a101760596625ad156d376a886a24a86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101760596625ad156d376a886a24a86a">&#9670;&nbsp;</a></span>functional_insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;T&gt; derecho::functional_insert </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts set b into set a and returns the modified a. </p>
<p>Hack to get around the fact that set::insert doesn't return *this. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The set to modify and return </td></tr>
    <tr><td class="paramname">b</td><td>The set that should be inserted into a. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Set a. </dd></dl>

<p class="definition">Definition at line <a class="el" href="group__impl_8h_source.html#l00055">55</a> of file <a class="el" href="group__impl_8h_source.html">group_impl.h</a>.</p>

</div>
</div>
<a id="ab4f529cba0c6b56c083b5044113b13e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f529cba0c6b56c083b5044113b13e3">&#9670;&nbsp;</a></span>identical_subgroups_policy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structderecho_1_1SubgroupAllocationPolicy.html">SubgroupAllocationPolicy</a> derecho::identical_subgroups_policy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_subgroups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structderecho_1_1ShardAllocationPolicy.html">ShardAllocationPolicy</a> &amp;&#160;</td>
          <td class="paramname"><em>subgroup_policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="structderecho_1_1SubgroupAllocationPolicy.html">SubgroupAllocationPolicy</a> for a replicated type that needs n subgroups with identical sharding policies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_subgroups</td><td>The number of subgroups to create. </td></tr>
    <tr><td class="paramname">subgroup_policy</td><td>The policy to use for sharding each subgroup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structderecho_1_1SubgroupAllocationPolicy.html">SubgroupAllocationPolicy</a> for a replicated type with num_subgroups copies of the same subgroup. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subgroup__functions_8cpp_source.html#l00047">47</a> of file <a class="el" href="subgroup__functions_8cpp_source.html">subgroup_functions.cpp</a>.</p>

</div>
</div>
<a id="a6323c39d344380e5859dd390856c7ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6323c39d344380e5859dd390856c7ea4">&#9670;&nbsp;</a></span>index_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t derecho::index_of </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to find the index of an element in a container. </p>

<p class="definition">Definition at line <a class="el" href="multicast__group_8cpp_source.html#l00017">17</a> of file <a class="el" href="multicast__group_8cpp_source.html">multicast_group.cpp</a>.</p>

</div>
</div>
<a id="a1ff5fa530d9a8219fc5c5dd69a7c89a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff5fa530d9a8219fc5c5dd69a7c89a8">&#9670;&nbsp;</a></span>keys_as_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;K&gt; derecho::keys_as_list </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a std::list of the keys in a std::map, in the same order as they appear in the std::map. </p>
<p>This is a general-purpose function that could have many uses, but it's included here because it is helpful in constructing membership_function_order when there are no dependencies between functions (thus, they should just run in the order of their appearance in the map). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A std::map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::list containing a copy of each key in the map, in the same order </dd></dl>

<p class="definition">Definition at line <a class="el" href="subgroup__info_8h_source.html#l00103">103</a> of file <a class="el" href="subgroup__info_8h_source.html">subgroup_info.h</a>.</p>

</div>
</div>
<a id="a7a4ed687e994d00b37422107ffc38204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4ed687e994d00b37422107ffc38204">&#9670;&nbsp;</a></span>kind_map_builder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MapType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void derecho::kind_map_builder </td>
          <td>(</td>
          <td class="paramtype">MapType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="group__impl_8h_source.html#l00015">15</a> of file <a class="el" href="group__impl_8h_source.html">group_impl.h</a>.</p>

</div>
</div>
<a id="a2da328941ec7107e38b82de353ab326a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da328941ec7107e38b82de353ab326a">&#9670;&nbsp;</a></span>kind_map_builder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MapType , typename FirstType , typename... RestTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void derecho::kind_map_builder </td>
          <td>(</td>
          <td class="paramtype">MapType &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacederecho.html#a169d9fd2f63d82f866b27a1bc7ee2708">Factory</a>&lt; FirstType &gt;&#160;</td>
          <td class="paramname"><em>curr_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacederecho.html#a169d9fd2f63d82f866b27a1bc7ee2708">Factory</a>&lt; RestTypes &gt;...&#160;</td>
          <td class="paramname"><em>rest_factories</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Actual implementation of make_kind_map; needs to be a separate function because the only way to build a KindMap is with a void mutator function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A mutable reference to the KindMap being constructed </td></tr>
    <tr><td class="paramname">curr_factory</td><td>The first factory in the parameter pack of factories </td></tr>
    <tr><td class="paramname">rest_factories</td><td>The rest of the parameter pack </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="group__impl_8h_source.html#l00025">25</a> of file <a class="el" href="group__impl_8h_source.html">group_impl.h</a>.</p>

</div>
</div>
<a id="a519d9262b85ce675c9b509593d3d6b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519d9262b85ce675c9b509593d3d6b1b">&#9670;&nbsp;</a></span>load_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classderecho_1_1View.html">View</a> &gt; derecho::load_view </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>view_file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Custom implementation of load_object for Views. </p>
<p>The <a class="el" href="classderecho_1_1View.html">View</a> from the swap file will be used if it is newer than the <a class="el" href="classderecho_1_1View.html">View</a> from view_file_name (according to VID), since this means a crash occurred before the swap file could be renamed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view_file_name</td><td>The name of the file to read for a serialized <a class="el" href="classderecho_1_1View.html">View</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classderecho_1_1View.html">View</a> constructed with the data in the file </dd></dl>

<p class="definition">Definition at line <a class="el" href="view_8cpp_source.html#l00256">256</a> of file <a class="el" href="view_8cpp_source.html">view.cpp</a>.</p>

</div>
</div>
<a id="a41ad962d14dcfbe9f3066656742b2552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ad962d14dcfbe9f3066656742b2552">&#9670;&nbsp;</a></span>make_kind_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mutils::KindMap&lt;<a class="el" href="namespacederecho.html#a169d9fd2f63d82f866b27a1bc7ee2708">Factory</a>, Types...&gt; derecho::make_kind_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacederecho.html#a169d9fd2f63d82f866b27a1bc7ee2708">Factory</a>&lt; Types &gt;...&#160;</td>
          <td class="paramname"><em>factories</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a KindMap&lt;Factory, Types...&gt; from a list of factories of those types. </p>
<p>Could probably be made even more generic, to construct a KindMap of any template given a list of objects that match that template, but that would involve writing a template template parameter, which is too much black magic for me to understand. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factories</td><td>One instance of Factory&lt;T&gt; for each T in the type list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A KindMap of factories, mapping each type to a Factory for that type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="group__impl_8h_source.html#l00041">41</a> of file <a class="el" href="group__impl_8h_source.html">group_impl.h</a>.</p>

</div>
</div>
<a id="ade41f7c45f3d0d8dca45a575448c7169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade41f7c45f3d0d8dca45a575448c7169">&#9670;&nbsp;</a></span>make_next_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classderecho_1_1View.html">View</a> &gt; derecho::make_next_view </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classderecho_1_1View.html">View</a> &amp;&#160;</td>
          <td class="paramname"><em>curr_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>leave_ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacederecho.html#aa3ec8cb782d4904ba3eaa68bcf3a9362">node_id_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>joiner_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacederecho.html#a82b280cc024a2495afc8337635c38bab">ip_addr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>joiner_ips</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the next <a class="el" href="classderecho_1_1View.html">View</a> given the current <a class="el" href="classderecho_1_1View.html">View</a> and the set of failures and joins. </p>
<p>Uses exactly the same logic as the "initialize the next view" section of the start_view_change predicate, with the crucial difference that retrieving the joiner IPs from the SST has been stripped out (the joiner IPs are assumed to be known already) so that it doesn't need an SST to run correctly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curr_view</td><td>The current <a class="el" href="classderecho_1_1View.html">View</a> </td></tr>
    <tr><td class="paramname">leave_ranks</td><td>The ranks (in the current <a class="el" href="classderecho_1_1View.html">View</a>'s members list) of members that are leaving </td></tr>
    <tr><td class="paramname">joiner_ids</td><td>The IDs of new nodes that are joining </td></tr>
    <tr><td class="paramname">joiner_ips</td><td>The IP addresses of the new nodes that are joining, in the same order as their corresponding IDs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classderecho_1_1View.html">View</a> with the joins and leaves applied </dd></dl>

<p class="definition">Definition at line <a class="el" href="subgroup__function__tester_8cpp_source.html#l00179">179</a> of file <a class="el" href="subgroup__function__tester_8cpp_source.html">subgroup_function_tester.cpp</a>.</p>

</div>
</div>
<a id="a1ae7da5e3f17c51c3531d00a53fbc2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae7da5e3f17c51c3531d00a53fbc2cc">&#9670;&nbsp;</a></span>one_subgroup_entire_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacederecho.html#a3b0ee73d7d0341de956f33edb2878e20">subgroup_shard_layout_t</a> derecho::one_subgroup_entire_view </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classderecho_1_1View.html">View</a> &amp;&#160;</td>
          <td class="paramname"><em>curr_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>next_unassigned_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>previous_was_successful</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="subgroup__functions_8cpp_source.html#l00016">16</a> of file <a class="el" href="subgroup__functions_8cpp_source.html">subgroup_functions.cpp</a>.</p>

</div>
</div>
<a id="af3e93d0c16376de991bd8c77092d706c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e93d0c16376de991bd8c77092d706c">&#9670;&nbsp;</a></span>one_subgroup_entire_view_raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacederecho.html#a3b0ee73d7d0341de956f33edb2878e20">subgroup_shard_layout_t</a> derecho::one_subgroup_entire_view_raw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classderecho_1_1View.html">View</a> &amp;&#160;</td>
          <td class="paramname"><em>curr_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>next_unassigned_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>previous_was_successful</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="subgroup__functions_8cpp_source.html#l00022">22</a> of file <a class="el" href="subgroup__functions_8cpp_source.html">subgroup_functions.cpp</a>.</p>

</div>
</div>
<a id="a7e8bf92a5d64fa9fb186b9bc71c79ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8bf92a5d64fa9fb186b9bc71c79ece">&#9670;&nbsp;</a></span>one_subgroup_policy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structderecho_1_1SubgroupAllocationPolicy.html">SubgroupAllocationPolicy</a> derecho::one_subgroup_policy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structderecho_1_1ShardAllocationPolicy.html">ShardAllocationPolicy</a> &amp;&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="structderecho_1_1SubgroupAllocationPolicy.html">SubgroupAllocationPolicy</a> for a replicated type that only has a single subgroup. </p>
<p>The <a class="el" href="structderecho_1_1ShardAllocationPolicy.html">ShardAllocationPolicy</a> argument can be the result of one of the <a class="el" href="structderecho_1_1ShardAllocationPolicy.html">ShardAllocationPolicy</a> helper functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>The allocation policy to use for the single subgroup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structderecho_1_1SubgroupAllocationPolicy.html">SubgroupAllocationPolicy</a> for a single-subgroup type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subgroup__functions_8cpp_source.html#l00043">43</a> of file <a class="el" href="subgroup__functions_8cpp_source.html">subgroup_functions.cpp</a>.</p>

</div>
</div>
<a id="ae02bbe8513bf93a849335511e0a0e348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02bbe8513bf93a849335511e0a0e348">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; derecho::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classderecho_1_1View.html">View</a> &amp;&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a plaintext representation of the <a class="el" href="classderecho_1_1View.html">View</a> to an output stream. </p>
<p>This is not interchangeable with the serialization library, but can be used to create a log file parseable by standard bash tools. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The output stream </td></tr>
    <tr><td class="paramname">view</td><td>The <a class="el" href="classderecho_1_1View.html">View</a> to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream </dd></dl>

<p class="definition">Definition at line <a class="el" href="view_8cpp_source.html#l00291">291</a> of file <a class="el" href="view_8cpp_source.html">view.cpp</a>.</p>

</div>
</div>
<a id="ad24795ddb9bbf45601d93e02fab4b246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24795ddb9bbf45601d93e02fab4b246">&#9670;&nbsp;</a></span>parse_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classderecho_1_1View.html">View</a> derecho::parse_view </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the plaintext representation created by operator&lt;&lt; and modifies the <a class="el" href="classderecho_1_1View.html">View</a> argument to contain the view it represents. </p>

<p class="definition">Definition at line <a class="el" href="view_8cpp_source.html#l00305">305</a> of file <a class="el" href="view_8cpp_source.html">view.cpp</a>.</p>

</div>
</div>
<a id="acc1bc9c5ac5e6c171fbb07a6c745d230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1bc9c5ac5e6c171fbb07a6c745d230">&#9670;&nbsp;</a></span>print_subgroup_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void derecho::print_subgroup_layout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacederecho.html#a3b0ee73d7d0341de956f33edb2878e20">subgroup_shard_layout_t</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the membership of a subgroup/shard layout to stdout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layout</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="subgroup__function__tester_8cpp_source.html#l00110">110</a> of file <a class="el" href="subgroup__function__tester_8cpp_source.html">subgroup_function_tester.cpp</a>.</p>

</div>
</div>
<a id="ab2cfda95d10697c3ce56bd9a041579cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2cfda95d10697c3ce56bd9a041579cc">&#9670;&nbsp;</a></span>raw_even_sharding_policy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structderecho_1_1ShardAllocationPolicy.html">ShardAllocationPolicy</a> derecho::raw_even_sharding_policy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_shards</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodes_per_shard</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="structderecho_1_1ShardAllocationPolicy.html">ShardAllocationPolicy</a> that specifies num_shards shards with the same number of nodes in each shard, and every shard running in "raw" delivery mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_shards</td><td>The number of shards to request in this policy. </td></tr>
    <tr><td class="paramname">nodes_per_shard</td><td>The number of nodes per shard to request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structderecho_1_1ShardAllocationPolicy.html">ShardAllocationPolicy</a> value with these parameters. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subgroup__functions_8cpp_source.html#l00033">33</a> of file <a class="el" href="subgroup__functions_8cpp_source.html">subgroup_functions.cpp</a>.</p>

</div>
</div>
<a id="a7c7e09a1f5bcd4328c061fd3ba66c81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7e09a1f5bcd4328c061fd3ba66c81b">&#9670;&nbsp;</a></span>test_provision_subgroups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void derecho::test_provision_subgroups </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structderecho_1_1SubgroupInfo.html">SubgroupInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>subgroup_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; <a class="el" href="classderecho_1_1View.html">View</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>prev_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classderecho_1_1View.html">View</a> &amp;&#160;</td>
          <td class="paramname"><em>curr_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs the same logic as <a class="el" href="classderecho_1_1ViewManager.html#a58d492d4c591f1dc00ccc0c1904f89f0" title="Initializes the current View with subgroup information, and creates the subgroup-settings map that Mu...">ViewManager::make_subgroup_maps()</a>, only without actually saving the subgroup_to_x maps. </p>
<p>curr_view is still updated with the subgroup assignments, though. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subgroup_info</td><td>The <a class="el" href="structderecho_1_1SubgroupInfo.html" title="Container for whatever information is needed to describe a Group&#39;s subgroups and shards. ">SubgroupInfo</a> to use for provisioning subgroups </td></tr>
    <tr><td class="paramname">prev_view</td><td>The previous view, if there was one, or nullptr </td></tr>
    <tr><td class="paramname">curr_view</td><td>The current view in which to assign subgroup membership </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="subgroup__function__tester_8cpp_source.html#l00121">121</a> of file <a class="el" href="subgroup__function__tester_8cpp_source.html">subgroup_function_tester.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 17 2018 12:49:41 for Derecho by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
