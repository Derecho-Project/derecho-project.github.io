<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Derecho: derecho Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Derecho
   &#160;<span id="projectnumber">0.9</span>
   </div>
   <div id="projectbrief">Distributed systems toolkit for RDMA</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">derecho Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacederecho_1_1gmssst"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho_1_1gmssst.html">gmssst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacederecho_1_1rpc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho_1_1rpc.html">rpc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1__Group.html">_Group</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1Bytes.html">Bytes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structderecho_1_1CallbackSet"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#structderecho_1_1CallbackSet">CallbackSet</a></td></tr>
<tr class="memdesc:structderecho_1_1CallbackSet"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bundles together a set of callback functions for message delivery events.  <a href="namespacederecho.html#structderecho_1_1CallbackSet">More...</a><br /></td></tr>
<tr class="separator:structderecho_1_1CallbackSet"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1Conf.html">Conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1CrossProductAllocator.html">CrossProductAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A shard_view_generator_t functor that creates a set of subgroups that is the "cross-product" of two subgroups, source and target.  <a href="classderecho_1_1CrossProductAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structderecho_1_1CrossProductPolicy"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#structderecho_1_1CrossProductPolicy">CrossProductPolicy</a></td></tr>
<tr class="memdesc:structderecho_1_1CrossProductPolicy"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alternate type of subgroup allocation policy for subgroup types whose membership will be defined as a cross-product of other subgroups.  <a href="namespacederecho.html#structderecho_1_1CrossProductPolicy">More...</a><br /></td></tr>
<tr class="separator:structderecho_1_1CrossProductPolicy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1DefaultSubgroupAllocator.html">DefaultSubgroupAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor of type shard_view_generator_t that implements the default subgroup allocation algorithm, parameterized based on a policy for each subgroup type (i.e.  <a href="classderecho_1_1DefaultSubgroupAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1derecho__exception.html">derecho_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base exception class for all exceptions raised by Derecho.  <a href="structderecho_1_1derecho__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1DerechoParams.html">DerechoParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bundles together a set of low-level parameters for configuring Derecho groups.  <a href="structderecho_1_1DerechoParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1DerechoSST.html">DerechoSST</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The GMS and derecho_group will share the same SST for efficiency.  <a href="classderecho_1_1DerechoSST.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1empty__reference__exception.html">empty_reference_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception that means a reference-like type is "empty" (does not contain a valid object).  <a href="structderecho_1_1empty__reference__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1ExternalCaller.html">ExternalCaller</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1Group.html">Group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The top-level object for creating a Derecho group.  <a href="classderecho_1_1Group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1GroupProjection.html">GroupProjection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1GroupReference.html">GroupReference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1IDeserializationContext.html">IDeserializationContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Deserialization Interface to be implemented by user applications.  <a href="structderecho_1_1IDeserializationContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1invalid__subgroup__exception.html">invalid_subgroup_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception that means the user made an invalid request for a subgroup handle, such as by supplying an out-of-bounds subgroup index.  <a href="structderecho_1_1invalid__subgroup__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structderecho_1_1JoinResponse"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#structderecho_1_1JoinResponse">JoinResponse</a></td></tr>
<tr class="memdesc:structderecho_1_1JoinResponse"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bundles together a JoinResponseCode and the leader's node ID, which it also needs to send to the new node that wants to join.  <a href="namespacederecho.html#structderecho_1_1JoinResponse">More...</a><br /></td></tr>
<tr class="separator:structderecho_1_1JoinResponse"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1LockedQueue.html">LockedQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A little helper class that implements a threadsafe queue by requiring all clients to lock a mutex before accessing the queue.  <a href="classderecho_1_1LockedQueue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1LockedReference.html">LockedReference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A little helper class that wraps together a reference and a lock on a related mutex.  <a href="classderecho_1_1LockedReference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1MessageBuffer.html">MessageBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a block of memory used to store a message.  <a href="structderecho_1_1MessageBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1MulticastGroup.html">MulticastGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the low-level mechanics of tracking multicasts in a Derecho group, using RDMC to deliver messages and SST to track their arrival and stability.  <a href="classderecho_1_1MulticastGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1PersistenceManager.html">PersistenceManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classderecho_1_1PersistenceManager.html" title="PersistenceManager is responsible for persisting all the data in a group. ">PersistenceManager</a> is responsible for persisting all the data in a group.  <a href="classderecho_1_1PersistenceManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1PersistsFields.html">PersistsFields</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a marker interface for user-defined <a class="el" href="classderecho_1_1Replicated.html">Replicated</a> Objects (i.e.  <a href="classderecho_1_1PersistsFields.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1RaggedTrim.html">RaggedTrim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the data needed to log a "ragged trim" decision to disk.  <a href="structderecho_1_1RaggedTrim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1RawObject.html">RawObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An empty class to be used as the "replicated type" for a subgroup that doesn't implement a <a class="el" href="classderecho_1_1Replicated.html">Replicated</a> Object.  <a href="structderecho_1_1RawObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structderecho_1_1RDMCMessage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#structderecho_1_1RDMCMessage">RDMCMessage</a></td></tr>
<tr class="memdesc:structderecho_1_1RDMCMessage"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure containing an RDMC message (which consists of some bytes in a registered memory region) and some associated metadata.  <a href="namespacederecho.html#structderecho_1_1RDMCMessage">More...</a><br /></td></tr>
<tr class="separator:structderecho_1_1RDMCMessage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1Replicated.html">Replicated</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1ReplicatedObject.html">ReplicatedObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common interface for all types of Replicated&lt;T&gt;, specifying some methods for state transfer and persistence.  <a href="classderecho_1_1ReplicatedObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1RestartLeaderState.html">RestartLeaderState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1RestartState.html">RestartState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structderecho_1_1ShardAllocationPolicy"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy">ShardAllocationPolicy</a></td></tr>
<tr class="separator:structderecho_1_1ShardAllocationPolicy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1ShardIterator.html">ShardIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structderecho_1_1SSTMessage"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#structderecho_1_1SSTMessage">SSTMessage</a></td></tr>
<tr class="separator:structderecho_1_1SSTMessage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1subgroup__provisioning__exception.html">subgroup_provisioning_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception that indicates that a subgroup membership function was unable to finish executing because its enclosing <a class="el" href="classderecho_1_1Group.html" title="The top-level object for creating a Derecho group. ">Group</a> was not in a valid state.  <a href="classderecho_1_1subgroup__provisioning__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structderecho_1_1SubgroupAllocationPolicy"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#structderecho_1_1SubgroupAllocationPolicy">SubgroupAllocationPolicy</a></td></tr>
<tr class="memdesc:structderecho_1_1SubgroupAllocationPolicy"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data structure defining the parameters of the default subgroup allocation function for a single subgroup type.  <a href="namespacederecho.html#structderecho_1_1SubgroupAllocationPolicy">More...</a><br /></td></tr>
<tr class="separator:structderecho_1_1SubgroupAllocationPolicy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structderecho_1_1SubgroupInfo.html">SubgroupInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for whatever information is needed to describe a <a class="el" href="classderecho_1_1Group.html" title="The top-level object for creating a Derecho group. ">Group</a>'s subgroups and shards.  <a href="structderecho_1_1SubgroupInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structderecho_1_1SubgroupSettings"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#structderecho_1_1SubgroupSettings">SubgroupSettings</a></td></tr>
<tr class="memdesc:structderecho_1_1SubgroupSettings"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of settings for a single subgroup that this node is a member of.  <a href="namespacederecho.html#structderecho_1_1SubgroupSettings">More...</a><br /></td></tr>
<tr class="separator:structderecho_1_1SubgroupSettings"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1SubView.html">SubView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The subset of a <a class="el" href="classderecho_1_1View.html">View</a> associated with a single shard, or a single subgroup if the subgroup is non-sharded.  <a href="classderecho_1_1SubView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1View.html">View</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classderecho_1_1ViewManager.html">ViewManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5166c1baf8aaf072658901fa0ec4e06d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a> = uint32_t</td></tr>
<tr class="memdesc:a5166c1baf8aaf072658901fa0ec4e06d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for the internal Subgroup IDs generated by <a class="el" href="classderecho_1_1ViewManager.html">ViewManager</a>.  <a href="#a5166c1baf8aaf072658901fa0ec4e06d">More...</a><br /></td></tr>
<tr class="separator:a5166c1baf8aaf072658901fa0ec4e06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7594bd002094b1ea329f4452fbb9829b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a7594bd002094b1ea329f4452fbb9829b">message_id_t</a> = int32_t</td></tr>
<tr class="memdesc:a7594bd002094b1ea329f4452fbb9829b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a message's unique "sequence number" or index.  <a href="#a7594bd002094b1ea329f4452fbb9829b">More...</a><br /></td></tr>
<tr class="separator:a7594bd002094b1ea329f4452fbb9829b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5e9c5fbee4788f4451aa097bb75ea2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#ada5e9c5fbee4788f4451aa097bb75ea2">subgroup_type_id_t</a> = uint32_t</td></tr>
<tr class="memdesc:ada5e9c5fbee4788f4451aa097bb75ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the numeric ID used to refer to subgroup types within a <a class="el" href="classderecho_1_1Group.html" title="The top-level object for creating a Derecho group. ">Group</a>; this is currently computed as the index of the subgroup type within <a class="el" href="classderecho_1_1Group.html" title="The top-level object for creating a Derecho group. ">Group</a>'s template parameters.  <a href="#ada5e9c5fbee4788f4451aa097bb75ea2">More...</a><br /></td></tr>
<tr class="separator:ada5e9c5fbee4788f4451aa097bb75ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd42537160f9d1f1734a20fc81a5d89"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a4dd42537160f9d1f1734a20fc81a5d89">message_callback_t</a> = std::function&lt; void(<a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a>, <a class="el" href="derecho__type__definitions_8h.html#a307ecfdca0e28f653d9138dc0f676a77">node_id_t</a>, <a class="el" href="namespacederecho.html#a7594bd002094b1ea329f4452fbb9829b">message_id_t</a>, std::optional&lt; std::pair&lt; char *, long long int &gt; &gt;, persistent::version_t)&gt;</td></tr>
<tr class="memdesc:a4dd42537160f9d1f1734a20fc81a5d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the type of std::function that is used for message delivery event callbacks.  <a href="#a4dd42537160f9d1f1734a20fc81a5d89">More...</a><br /></td></tr>
<tr class="separator:a4dd42537160f9d1f1734a20fc81a5d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8624716823ab496a6dd95c15363067a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#ac8624716823ab496a6dd95c15363067a">persistence_callback_t</a> = std::function&lt; void(<a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a>, persistent::version_t)&gt;</td></tr>
<tr class="separator:ac8624716823ab496a6dd95c15363067a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7555b404c6d334bdc241de6bb8534c39"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a7555b404c6d334bdc241de6bb8534c39">rpc_handler_t</a> = std::function&lt; void(<a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a>, <a class="el" href="derecho__type__definitions_8h.html#a307ecfdca0e28f653d9138dc0f676a77">node_id_t</a>, char *, uint32_t)&gt;</td></tr>
<tr class="separator:a7555b404c6d334bdc241de6bb8534c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335eb348e6d356901249c74bdf489063"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a335eb348e6d356901249c74bdf489063"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a335eb348e6d356901249c74bdf489063">Factory</a> = std::function&lt; std::unique_ptr&lt; T &gt;(persistent::PersistentRegistry *)&gt;</td></tr>
<tr class="memdesc:a335eb348e6d356901249c74bdf489063"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of factory function the user must provide to the <a class="el" href="classderecho_1_1Group.html" title="The top-level object for creating a Derecho group. ">Group</a> constructor, to construct each <a class="el" href="classderecho_1_1Replicated.html">Replicated</a> Object that is assigned to a subgroup.  <a href="#a335eb348e6d356901249c74bdf489063">More...</a><br /></td></tr>
<tr class="separator:a335eb348e6d356901249c74bdf489063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36786abd0a6d38cc803ed6ca06ec887"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#ae36786abd0a6d38cc803ed6ca06ec887">persistence_manager_make_version_func_t</a> = std::function&lt; void(const <a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a> &amp;, const persistent::version_t &amp;, const HLC &amp;)&gt;</td></tr>
<tr class="separator:ae36786abd0a6d38cc803ed6ca06ec887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12df62f91ff8b3d30fe41c983f510f5c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a12df62f91ff8b3d30fe41c983f510f5c">persistence_manager_post_persist_func_t</a> = std::function&lt; void(const <a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a> &amp;, const persistent::version_t &amp;)&gt;</td></tr>
<tr class="separator:a12df62f91ff8b3d30fe41c983f510f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd25e81ead51e3f21992b9321fc06e5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a1dd25e81ead51e3f21992b9321fc06e5">persistence_manager_callbacks_t</a> = std::tuple&lt; <a class="el" href="namespacederecho.html#ae36786abd0a6d38cc803ed6ca06ec887">persistence_manager_make_version_func_t</a>, <a class="el" href="namespacederecho.html#a12df62f91ff8b3d30fe41c983f510f5c">persistence_manager_post_persist_func_t</a> &gt;</td></tr>
<tr class="separator:a1dd25e81ead51e3f21992b9321fc06e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4d4017445fcee3d6976dc21260e36e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a2e4d4017445fcee3d6976dc21260e36e">subgroup_post_next_version_func_t</a> = std::function&lt; void(const <a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a> &amp;, const persistent::version_t &amp;)&gt;</td></tr>
<tr class="separator:a2e4d4017445fcee3d6976dc21260e36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa720b56816033b383662e805480cef01"><td class="memTemplParams" colspan="2">template&lt;typename TargetType , typename... TypePack&gt; </td></tr>
<tr class="memitem:aa720b56816033b383662e805480cef01"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#aa720b56816033b383662e805480cef01">contains</a> = std::integral_constant&lt; bool,(std::is_same&lt; TargetType, TypePack &gt;::value||...)&gt;</td></tr>
<tr class="memdesc:aa720b56816033b383662e805480cef01"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-trait-like template that provides a True member "value" if TargetType matches some type in TypePack (according to std::is_same), or provides a False member "value" if TargetType does not match anything in TypePack.  <a href="#aa720b56816033b383662e805480cef01">More...</a><br /></td></tr>
<tr class="separator:aa720b56816033b383662e805480cef01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55bb326016160eb730dc9fe0514c81c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa55bb326016160eb730dc9fe0514c81c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#aa55bb326016160eb730dc9fe0514c81c">replicated_index_map</a> = std::map&lt; uint32_t, <a class="el" href="classderecho_1_1Replicated.html">Replicated</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:aa55bb326016160eb730dc9fe0514c81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399961c8a9af951d5dc20f468f0e9ad0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a399961c8a9af951d5dc20f468f0e9ad0">persistence_request_t</a> = std::tuple&lt; <a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a>, persistent::version_t &gt;</td></tr>
<tr class="separator:a399961c8a9af951d5dc20f468f0e9ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae5633b492f5faf7c9f2bc514ac2d27"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ae5633b492f5faf7c9f2bc514ac2d27"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a9ae5633b492f5faf7c9f2bc514ac2d27">has_persistent_fields</a> = std::is_base_of&lt; <a class="el" href="classderecho_1_1PersistsFields.html">PersistsFields</a>, T &gt;</td></tr>
<tr class="memdesc:a9ae5633b492f5faf7c9f2bc514ac2d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template whose member field "value" will be true if type T inherits from <a class="el" href="classderecho_1_1PersistsFields.html" title="This is a marker interface for user-defined Replicated Objects (i.e. ">PersistsFields</a>, and false otherwise.  <a href="#a9ae5633b492f5faf7c9f2bc514ac2d27">More...</a><br /></td></tr>
<tr class="separator:a9ae5633b492f5faf7c9f2bc514ac2d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20e524ab297715d39fcd62eb367ca4a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#ad20e524ab297715d39fcd62eb367ca4a">ragged_trim_map_t</a> = std::map&lt; <a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a>, std::map&lt; uint32_t, std::unique_ptr&lt; <a class="el" href="structderecho_1_1RaggedTrim.html">RaggedTrim</a> &gt; &gt;&gt;</td></tr>
<tr class="memdesc:ad20e524ab297715d39fcd62eb367ca4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of logged ragged trim states, indexed by (subgroup ID, shard num), stored by pointer.  <a href="#ad20e524ab297715d39fcd62eb367ca4a">More...</a><br /></td></tr>
<tr class="separator:ad20e524ab297715d39fcd62eb367ca4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0ee73d7d0341de956f33edb2878e20"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a3b0ee73d7d0341de956f33edb2878e20">subgroup_shard_layout_t</a> = std::vector&lt; std::vector&lt; <a class="el" href="classderecho_1_1SubView.html">SubView</a> &gt; &gt;</td></tr>
<tr class="memdesc:a3b0ee73d7d0341de956f33edb2878e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data structure used to store a subgroups-and-shards layout for a single subgroup type (i.e.  <a href="#a3b0ee73d7d0341de956f33edb2878e20">More...</a><br /></td></tr>
<tr class="separator:a3b0ee73d7d0341de956f33edb2878e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b27d622f2dc4732352ef110f519ad1f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a8b27d622f2dc4732352ef110f519ad1f">shard_view_generator_t</a> = std::function&lt; <a class="el" href="namespacederecho.html#a3b0ee73d7d0341de956f33edb2878e20">subgroup_shard_layout_t</a>(const std::type_index &amp;, const std::unique_ptr&lt; <a class="el" href="classderecho_1_1View.html">View</a> &gt; &amp;, <a class="el" href="classderecho_1_1View.html">View</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a8b27d622f2dc4732352ef110f519ad1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a lambda function that generates subgroup and shard views for a specific subgroup type.  <a href="#a8b27d622f2dc4732352ef110f519ad1f">More...</a><br /></td></tr>
<tr class="separator:a8b27d622f2dc4732352ef110f519ad1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b5717079bf92d1ec04efa8660a327e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#aa0b5717079bf92d1ec04efa8660a327e">lock_guard_t</a> = std::lock_guard&lt; std::mutex &gt;</td></tr>
<tr class="separator:aa0b5717079bf92d1ec04efa8660a327e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c56618eccc62191c8504856cfd9d18"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#ae6c56618eccc62191c8504856cfd9d18">unique_lock_t</a> = std::unique_lock&lt; std::mutex &gt;</td></tr>
<tr class="separator:ae6c56618eccc62191c8504856cfd9d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2cd00140eaa031b4056c2c51caef18"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#aff2cd00140eaa031b4056c2c51caef18">shared_lock_t</a> = std::shared_lock&lt; std::shared_timed_mutex &gt;</td></tr>
<tr class="separator:aff2cd00140eaa031b4056c2c51caef18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d358a67fa805be8a898a6e19f3e225"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab9d358a67fa805be8a898a6e19f3e225"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#ab9d358a67fa805be8a898a6e19f3e225">SharedLockedReference</a> = <a class="el" href="classderecho_1_1LockedReference.html">LockedReference</a>&lt; std::shared_lock&lt; std::shared_timed_mutex &gt;, T &gt;</td></tr>
<tr class="separator:ab9d358a67fa805be8a898a6e19f3e225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8847e67ac70cd55aa5114fc3294aa326"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a8847e67ac70cd55aa5114fc3294aa326">view_upcall_t</a> = std::function&lt; void(const <a class="el" href="classderecho_1_1View.html">View</a> &amp;)&gt;</td></tr>
<tr class="separator:a8847e67ac70cd55aa5114fc3294aa326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f35a3df9a34d833d6e17643028ce2cd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a9f35a3df9a34d833d6e17643028ce2cd">vector_int64_2d</a> = std::vector&lt; std::vector&lt; int64_t &gt; &gt;</td></tr>
<tr class="memdesc:a9f35a3df9a34d833d6e17643028ce2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a 2-dimensional vector used to store potential node IDs, or -1.  <a href="#a9f35a3df9a34d833d6e17643028ce2cd">More...</a><br /></td></tr>
<tr class="separator:a9f35a3df9a34d833d6e17643028ce2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1fb14b9518cde9d5f222d1d6039b8bdc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a1fb14b9518cde9d5f222d1d6039b8bdc">Mode</a> { <a class="el" href="namespacederecho.html#a1fb14b9518cde9d5f222d1d6039b8bdcaabc458a817b34b4750413b587f536ac0">Mode::ORDERED</a>, 
<a class="el" href="namespacederecho.html#a1fb14b9518cde9d5f222d1d6039b8bdca6caf8ac543ee5994b1ab98021bba1173">Mode::UNORDERED</a>
 }</td></tr>
<tr class="separator:a1fb14b9518cde9d5f222d1d6039b8bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eda31de4dd1e1caa4329b6e3175f17e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a3eda31de4dd1e1caa4329b6e3175f17e">CommitMessage</a> { <a class="el" href="namespacederecho.html#a3eda31de4dd1e1caa4329b6e3175f17eab205205bc58adbefd02d8ba357b9c57f">CommitMessage::PREPARE</a>, 
<a class="el" href="namespacederecho.html#a3eda31de4dd1e1caa4329b6e3175f17ea1d0ba376e273b9d622641124d8c59264">CommitMessage::COMMIT</a>, 
<a class="el" href="namespacederecho.html#a3eda31de4dd1e1caa4329b6e3175f17ea8d12a2ca7e5a64036d7251a3eda51a38">CommitMessage::ABORT</a>
 }<tr class="memdesc:a3eda31de4dd1e1caa4329b6e3175f17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-safe set of messages that can be sent during two-phase commit.  <a href="namespacederecho.html#a3eda31de4dd1e1caa4329b6e3175f17e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3eda31de4dd1e1caa4329b6e3175f17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9128f4ac3ce2a84c9f7c7b5503378a12"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a9128f4ac3ce2a84c9f7c7b5503378a12">PORT_TYPE</a> { <a class="el" href="namespacederecho.html#a9128f4ac3ce2a84c9f7c7b5503378a12a2daba9851f81b62e00558f5f96447544">GMS</a> = 1, 
<a class="el" href="namespacederecho.html#a9128f4ac3ce2a84c9f7c7b5503378a12a296275e810353ddb092cabc68edbe31a">RPC</a>, 
<a class="el" href="namespacederecho.html#a9128f4ac3ce2a84c9f7c7b5503378a12affb3ca023a136b181de997dacdec756d">SST</a>, 
<a class="el" href="namespacederecho.html#a9128f4ac3ce2a84c9f7c7b5503378a12a0f1617776c11aca5e387e135371a48df">RDMC</a>
 }</td></tr>
<tr class="separator:a9128f4ac3ce2a84c9f7c7b5503378a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950a5aae55e86f79d1478dd9b142eeb4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a950a5aae55e86f79d1478dd9b142eeb4">JoinResponseCode</a> { <a class="el" href="namespacederecho.html#a950a5aae55e86f79d1478dd9b142eeb4ae0aa021e21dddbd6d8cecec71e9cf564">JoinResponseCode::OK</a>, 
<a class="el" href="namespacederecho.html#a950a5aae55e86f79d1478dd9b142eeb4a556cec21aa265c82893003ac91c61546">JoinResponseCode::TOTAL_RESTART</a>, 
<a class="el" href="namespacederecho.html#a950a5aae55e86f79d1478dd9b142eeb4a7bcc2a64209055d2ab40018c53bc9a03">JoinResponseCode::ID_IN_USE</a>, 
<a class="el" href="namespacederecho.html#a950a5aae55e86f79d1478dd9b142eeb4afc1ba884b5e3854e267da6f7c40bb48b">JoinResponseCode::LEADER_REDIRECT</a>
 }<tr class="memdesc:a950a5aae55e86f79d1478dd9b142eeb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of status codes the group leader can respond with upon initially receiving a connection request from a new node.  <a href="namespacederecho.html#a950a5aae55e86f79d1478dd9b142eeb4">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a950a5aae55e86f79d1478dd9b142eeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acc1bc9c5ac5e6c171fbb07a6c745d230"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#acc1bc9c5ac5e6c171fbb07a6c745d230">print_subgroup_layout</a> (const <a class="el" href="namespacederecho.html#a3b0ee73d7d0341de956f33edb2878e20">subgroup_shard_layout_t</a> &amp;layout)</td></tr>
<tr class="memdesc:acc1bc9c5ac5e6c171fbb07a6c745d230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the membership of a subgroup/shard layout to stdout.  <a href="#acc1bc9c5ac5e6c171fbb07a6c745d230">More...</a><br /></td></tr>
<tr class="separator:acc1bc9c5ac5e6c171fbb07a6c745d230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7e09a1f5bcd4328c061fd3ba66c81b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a7c7e09a1f5bcd4328c061fd3ba66c81b">test_provision_subgroups</a> (const <a class="el" href="structderecho_1_1SubgroupInfo.html">SubgroupInfo</a> &amp;subgroup_info, const std::unique_ptr&lt; <a class="el" href="classderecho_1_1View.html">View</a> &gt; &amp;prev_view, <a class="el" href="classderecho_1_1View.html">View</a> &amp;curr_view)</td></tr>
<tr class="memdesc:a7c7e09a1f5bcd4328c061fd3ba66c81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the same logic as <a class="el" href="classderecho_1_1ViewManager.html#a77d57b8010168e5ac01ee10471e30ebf" title="Initializes curr_view with subgroup information based on the membership functions in subgroup_info...">ViewManager::make_subgroup_maps()</a>, only without actually saving the subgroup_to_x maps.  <a href="#a7c7e09a1f5bcd4328c061fd3ba66c81b">More...</a><br /></td></tr>
<tr class="separator:a7c7e09a1f5bcd4328c061fd3ba66c81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560af875aa85bcc7ff733d46181b7f15"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classderecho_1_1View.html">View</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a560af875aa85bcc7ff733d46181b7f15">make_next_view</a> (const <a class="el" href="classderecho_1_1View.html">View</a> &amp;curr_view, const std::set&lt; int &gt; &amp;leave_ranks, const std::vector&lt; <a class="el" href="derecho__type__definitions_8h.html#a307ecfdca0e28f653d9138dc0f676a77">node_id_t</a> &gt; &amp;joiner_ids, const std::vector&lt; std::tuple&lt; <a class="el" href="derecho__type__definitions_8h.html#ab11e09092fcdbb0202a500479b3939b4">ip_addr_t</a>, uint16_t, uint16_t, uint16_t, uint16_t &gt;&gt; &amp;joiner_ips_and_ports)</td></tr>
<tr class="memdesc:a560af875aa85bcc7ff733d46181b7f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the next <a class="el" href="classderecho_1_1View.html">View</a> given the current <a class="el" href="classderecho_1_1View.html">View</a> and the set of failures and joins.  <a href="#a560af875aa85bcc7ff733d46181b7f15">More...</a><br /></td></tr>
<tr class="separator:a560af875aa85bcc7ff733d46181b7f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d9651d962300c3c8119413eb159423"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a21d9651d962300c3c8119413eb159423">getConfString</a> (const std::string &amp;key)</td></tr>
<tr class="separator:a21d9651d962300c3c8119413eb159423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e4c6d00f3d763914f45c779f922f32"><td class="memItemLeft" align="right" valign="top">const int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#aa0e4c6d00f3d763914f45c779f922f32">getConfInt32</a> (const std::string &amp;key)</td></tr>
<tr class="separator:aa0e4c6d00f3d763914f45c779f922f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c26a899c4a6d5b4139f74276db2a521"><td class="memItemLeft" align="right" valign="top">const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a3c26a899c4a6d5b4139f74276db2a521">getConfUInt32</a> (const std::string &amp;key)</td></tr>
<tr class="separator:a3c26a899c4a6d5b4139f74276db2a521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3985963f9c358dab086d964cccf609fb"><td class="memItemLeft" align="right" valign="top">const int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a3985963f9c358dab086d964cccf609fb">getConfInt16</a> (const std::string &amp;key)</td></tr>
<tr class="separator:a3985963f9c358dab086d964cccf609fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7758c7071c03e509d7f9a434a521585"><td class="memItemLeft" align="right" valign="top">const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#ae7758c7071c03e509d7f9a434a521585">getConfUInt16</a> (const std::string &amp;key)</td></tr>
<tr class="separator:ae7758c7071c03e509d7f9a434a521585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d13b01722e150a804d2b6446dedc47b"><td class="memItemLeft" align="right" valign="top">const int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a4d13b01722e150a804d2b6446dedc47b">getConfInt64</a> (const std::string &amp;key)</td></tr>
<tr class="separator:a4d13b01722e150a804d2b6446dedc47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a7e827260bb1a773cc4de67ad65028"><td class="memItemLeft" align="right" valign="top">const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a83a7e827260bb1a773cc4de67ad65028">getConfUInt64</a> (const std::string &amp;key)</td></tr>
<tr class="separator:a83a7e827260bb1a773cc4de67ad65028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addab4baa5299eac871a6c018e5f58bd9"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#addab4baa5299eac871a6c018e5f58bd9">getConfFloat</a> (const std::string &amp;key)</td></tr>
<tr class="separator:addab4baa5299eac871a6c018e5f58bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fafd7ffbc928b499f28db6b88e55fb"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#aa5fafd7ffbc928b499f28db6b88e55fb">getConfDouble</a> (const std::string &amp;key)</td></tr>
<tr class="separator:aa5fafd7ffbc928b499f28db6b88e55fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71ddbb2248f79d945b580442aef0855"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#ae71ddbb2248f79d945b580442aef0855">getConfBoolean</a> (const std::string &amp;key)</td></tr>
<tr class="separator:ae71ddbb2248f79d945b580442aef0855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea4422a6dc28bd2d7cbc61852855e91"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a1ea4422a6dc28bd2d7cbc61852855e91">hasCustomizedConfKey</a> (const std::string &amp;key)</td></tr>
<tr class="separator:a1ea4422a6dc28bd2d7cbc61852855e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101760596625ad156d376a886a24a86a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a101760596625ad156d376a886a24a86a"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a101760596625ad156d376a886a24a86a">functional_insert</a> (std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a101760596625ad156d376a886a24a86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts set b into set a and returns the modified a.  <a href="#a101760596625ad156d376a886a24a86a">More...</a><br /></td></tr>
<tr class="separator:a101760596625ad156d376a886a24a86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9f13b79bd4400e58b85629b9c97f13"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada9f13b79bd4400e58b85629b9c97f13"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#ada9f13b79bd4400e58b85629b9c97f13">functional_append</a> (const std::vector&lt; T &gt; &amp;original, const T &amp;item)</td></tr>
<tr class="memdesc:ada9f13b79bd4400e58b85629b9c97f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base case for functional_append, with one argument.  <a href="#ada9f13b79bd4400e58b85629b9c97f13">More...</a><br /></td></tr>
<tr class="separator:ada9f13b79bd4400e58b85629b9c97f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8638b3b0dab113f03fe666ae15653f01"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... RestArgs&gt; </td></tr>
<tr class="memitem:a8638b3b0dab113f03fe666ae15653f01"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a8638b3b0dab113f03fe666ae15653f01">functional_append</a> (const std::vector&lt; T &gt; &amp;original, const T &amp;first_item, RestArgs... rest_items)</td></tr>
<tr class="memdesc:a8638b3b0dab113f03fe666ae15653f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new std::vector value that is equal to the parameter std::vector with the rest of the arguments appended.  <a href="#a8638b3b0dab113f03fe666ae15653f01">More...</a><br /></td></tr>
<tr class="separator:a8638b3b0dab113f03fe666ae15653f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005ecde09c73e873a687e9a573f2cd53"><td class="memTemplParams" colspan="2">template&lt;typename K1 , typename K2 , typename V &gt; </td></tr>
<tr class="memitem:a005ecde09c73e873a687e9a573f2cd53"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a005ecde09c73e873a687e9a573f2cd53">multimap_size</a> (const std::map&lt; K1, std::map&lt; K2, V &gt;&gt; &amp;multimap)</td></tr>
<tr class="memdesc:a005ecde09c73e873a687e9a573f2cd53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of a std::map of std::maps, by counting up the sizes of all the inner maps.  <a href="#a005ecde09c73e873a687e9a573f2cd53">More...</a><br /></td></tr>
<tr class="separator:a005ecde09c73e873a687e9a573f2cd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff5fa530d9a8219fc5c5dd69a7c89a8"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a1ff5fa530d9a8219fc5c5dd69a7c89a8"><td class="memTemplItemLeft" align="right" valign="top">std::list&lt; K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a1ff5fa530d9a8219fc5c5dd69a7c89a8">keys_as_list</a> (const std::map&lt; K, V &gt; &amp;map)</td></tr>
<tr class="memdesc:a1ff5fa530d9a8219fc5c5dd69a7c89a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a std::list of the keys in a std::map, in the same order as they appear in the std::map.  <a href="#a1ff5fa530d9a8219fc5c5dd69a7c89a8">More...</a><br /></td></tr>
<tr class="separator:a1ff5fa530d9a8219fc5c5dd69a7c89a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf60bf445567e2de3aab74a3c7092cc1"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:acf60bf445567e2de3aab74a3c7092cc1"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#acf60bf445567e2de3aab74a3c7092cc1">index_of</a> (const Container &amp;container, const typename Container::value_type &amp;elem)</td></tr>
<tr class="memdesc:acf60bf445567e2de3aab74a3c7092cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a value in a STL container, and returns the index of that value in the container.  <a href="#acf60bf445567e2de3aab74a3c7092cc1">More...</a><br /></td></tr>
<tr class="separator:acf60bf445567e2de3aab74a3c7092cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cde0180ea838f8ca4e5cd7b84959c0f"><td class="memTemplParams" colspan="2">template&lt;uint32_t counter, typename TargetType , typename FirstType , typename... RestTypes&gt; </td></tr>
<tr class="memitem:a1cde0180ea838f8ca4e5cd7b84959c0f"><td class="memTemplItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a1cde0180ea838f8ca4e5cd7b84959c0f">index_of_type_impl</a> ()</td></tr>
<tr class="memdesc:a1cde0180ea838f8ca4e5cd7b84959c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function that implements index_of_type, which is separate to hide the "counter" template parameter (an implementation detail only used to maintain state across recursive calls).  <a href="#a1cde0180ea838f8ca4e5cd7b84959c0f">More...</a><br /></td></tr>
<tr class="separator:a1cde0180ea838f8ca4e5cd7b84959c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4ed687e994d00b37422107ffc38204"><td class="memTemplParams" colspan="2">template&lt;typename MapType &gt; </td></tr>
<tr class="memitem:a7a4ed687e994d00b37422107ffc38204"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a7a4ed687e994d00b37422107ffc38204">kind_map_builder</a> (MapType &amp;)</td></tr>
<tr class="separator:a7a4ed687e994d00b37422107ffc38204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da328941ec7107e38b82de353ab326a"><td class="memTemplParams" colspan="2">template&lt;typename MapType , typename FirstType , typename... RestTypes&gt; </td></tr>
<tr class="memitem:a2da328941ec7107e38b82de353ab326a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a2da328941ec7107e38b82de353ab326a">kind_map_builder</a> (MapType &amp;map, <a class="el" href="namespacederecho.html#a335eb348e6d356901249c74bdf489063">Factory</a>&lt; FirstType &gt; curr_factory, <a class="el" href="namespacederecho.html#a335eb348e6d356901249c74bdf489063">Factory</a>&lt; RestTypes &gt;... rest_factories)</td></tr>
<tr class="memdesc:a2da328941ec7107e38b82de353ab326a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual implementation of make_kind_map; needs to be a separate function because the only way to build a KindMap is with a void mutator function.  <a href="#a2da328941ec7107e38b82de353ab326a">More...</a><br /></td></tr>
<tr class="separator:a2da328941ec7107e38b82de353ab326a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ad962d14dcfbe9f3066656742b2552"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a41ad962d14dcfbe9f3066656742b2552"><td class="memTemplItemLeft" align="right" valign="top">mutils::KindMap&lt; <a class="el" href="namespacederecho.html#a335eb348e6d356901249c74bdf489063">Factory</a>, Types... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a41ad962d14dcfbe9f3066656742b2552">make_kind_map</a> (<a class="el" href="namespacederecho.html#a335eb348e6d356901249c74bdf489063">Factory</a>&lt; Types &gt;... factories)</td></tr>
<tr class="memdesc:a41ad962d14dcfbe9f3066656742b2552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a KindMap&lt;Factory, Types...&gt; from a list of factories of those types.  <a href="#a41ad962d14dcfbe9f3066656742b2552">More...</a><br /></td></tr>
<tr class="separator:a41ad962d14dcfbe9f3066656742b2552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6323c39d344380e5859dd390856c7ea4"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a6323c39d344380e5859dd390856c7ea4"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a6323c39d344380e5859dd390856c7ea4">index_of</a> (T container, U elem)</td></tr>
<tr class="memdesc:a6323c39d344380e5859dd390856c7ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to find the index of an element in a container.  <a href="#a6323c39d344380e5859dd390856c7ea4">More...</a><br /></td></tr>
<tr class="separator:a6323c39d344380e5859dd390856c7ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136390448e35fec19f72933c9bcdef80"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a136390448e35fec19f72933c9bcdef80">__attribute__</a> ((__packed__)) header</td></tr>
<tr class="memdesc:a136390448e35fec19f72933c9bcdef80"><td class="mdescLeft">&#160;</td><td class="mdescRight">The header for an individual multicast message, which will always be the first sizeof(header) bytes in the message's data buffer.  <a href="#a136390448e35fec19f72933c9bcdef80">More...</a><br /></td></tr>
<tr class="separator:a136390448e35fec19f72933c9bcdef80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972ce05a66dc751eebde761e9cde76d5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structderecho_1_1RawObject.html">RawObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a972ce05a66dc751eebde761e9cde76d5">raw_object_factory</a> (PersistentRegistry *)</td></tr>
<tr class="memdesc:a972ce05a66dc751eebde761e9cde76d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of Factory&lt;T&gt; for <a class="el" href="structderecho_1_1RawObject.html" title="An empty class to be used as the &quot;replicated type&quot; for a subgroup that doesn&#39;t implement a Replicated...">RawObject</a>, which is trivial because RawObjects have no state.  <a href="#a972ce05a66dc751eebde761e9cde76d5">More...</a><br /></td></tr>
<tr class="separator:a972ce05a66dc751eebde761e9cde76d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7e60886bce957926410b3692a4488a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#ade7e60886bce957926410b3692a4488a">ragged_trim_filename</a> (<a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a> subgroup_num, uint32_t shard_num)</td></tr>
<tr class="memdesc:ade7e60886bce957926410b3692a4488a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a filename to use for a <a class="el" href="structderecho_1_1RaggedTrim.html" title="Represents the data needed to log a &quot;ragged trim&quot; decision to disk. ">RaggedTrim</a> logged to disk using its subgroup and shard IDs.  <a href="#ade7e60886bce957926410b3692a4488a">More...</a><br /></td></tr>
<tr class="separator:ade7e60886bce957926410b3692a4488a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1857f085d6fa99a39d172204c13a6e5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacederecho.html#a3b0ee73d7d0341de956f33edb2878e20">subgroup_shard_layout_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a1857f085d6fa99a39d172204c13a6e5e">one_subgroup_entire_view</a> (const std::type_index &amp;subgroup_type, const std::unique_ptr&lt; <a class="el" href="classderecho_1_1View.html">View</a> &gt; &amp;prev_view, <a class="el" href="classderecho_1_1View.html">View</a> &amp;curr_view)</td></tr>
<tr class="memdesc:a1857f085d6fa99a39d172204c13a6e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple implementation of shard_view_generator_t that returns a single, un-sharded subgroup containing all the members of curr_view, regardless of what subgroup type is supplied.  <a href="#a1857f085d6fa99a39d172204c13a6e5e">More...</a><br /></td></tr>
<tr class="separator:a1857f085d6fa99a39d172204c13a6e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d60246631954534874da5fc4a8a0d80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacederecho.html#a3b0ee73d7d0341de956f33edb2878e20">subgroup_shard_layout_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a9d60246631954534874da5fc4a8a0d80">one_subgroup_entire_view_raw</a> (const std::type_index &amp;subgroup_type, const std::unique_ptr&lt; <a class="el" href="classderecho_1_1View.html">View</a> &gt; &amp;prev_view, <a class="el" href="classderecho_1_1View.html">View</a> &amp;curr_view)</td></tr>
<tr class="memdesc:a9d60246631954534874da5fc4a8a0d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple implementation of shard_view_generator_t that returns a single, un-sharded subgroup in Unordered (Raw) mode containing all the members of curr_view, regardless of what subgroup type is supplied.  <a href="#a9d60246631954534874da5fc4a8a0d80">More...</a><br /></td></tr>
<tr class="separator:a9d60246631954534874da5fc4a8a0d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0243871e8d5df1613d3fdde7a34af9f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy">ShardAllocationPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a0243871e8d5df1613d3fdde7a34af9f7">even_sharding_policy</a> (int num_shards, int nodes_per_shard)</td></tr>
<tr class="memdesc:a0243871e8d5df1613d3fdde7a34af9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy">ShardAllocationPolicy</a> that specifies num_shards shards with the same number of nodes in each shard.  <a href="#a0243871e8d5df1613d3fdde7a34af9f7">More...</a><br /></td></tr>
<tr class="separator:a0243871e8d5df1613d3fdde7a34af9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2cfda95d10697c3ce56bd9a041579cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy">ShardAllocationPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#ab2cfda95d10697c3ce56bd9a041579cc">raw_even_sharding_policy</a> (int num_shards, int nodes_per_shard)</td></tr>
<tr class="memdesc:ab2cfda95d10697c3ce56bd9a041579cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy">ShardAllocationPolicy</a> that specifies num_shards shards with the same number of nodes in each shard, and every shard running in "raw" delivery mode.  <a href="#ab2cfda95d10697c3ce56bd9a041579cc">More...</a><br /></td></tr>
<tr class="separator:ab2cfda95d10697c3ce56bd9a041579cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea7b838acf6fc6bf2e54dd886c2cb7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy">ShardAllocationPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#afea7b838acf6fc6bf2e54dd886c2cb7b">custom_shards_policy</a> (const std::vector&lt; int &gt; &amp;num_nodes_by_shard, const std::vector&lt; <a class="el" href="namespacederecho.html#a1fb14b9518cde9d5f222d1d6039b8bdc">Mode</a> &gt; &amp;delivery_modes_by_shard)</td></tr>
<tr class="memdesc:afea7b838acf6fc6bf2e54dd886c2cb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy">ShardAllocationPolicy</a> for a subgroup that has a different number of members in each shard, and possibly has each shard in a different delivery mode.  <a href="#afea7b838acf6fc6bf2e54dd886c2cb7b">More...</a><br /></td></tr>
<tr class="separator:afea7b838acf6fc6bf2e54dd886c2cb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8bf92a5d64fa9fb186b9bc71c79ece"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacederecho.html#structderecho_1_1SubgroupAllocationPolicy">SubgroupAllocationPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a7e8bf92a5d64fa9fb186b9bc71c79ece">one_subgroup_policy</a> (const <a class="el" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy">ShardAllocationPolicy</a> &amp;policy)</td></tr>
<tr class="memdesc:a7e8bf92a5d64fa9fb186b9bc71c79ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="namespacederecho.html#structderecho_1_1SubgroupAllocationPolicy" title="A data structure defining the parameters of the default subgroup allocation function for a single sub...">SubgroupAllocationPolicy</a> for a replicated type that only has a single subgroup.  <a href="#a7e8bf92a5d64fa9fb186b9bc71c79ece">More...</a><br /></td></tr>
<tr class="separator:a7e8bf92a5d64fa9fb186b9bc71c79ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f529cba0c6b56c083b5044113b13e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacederecho.html#structderecho_1_1SubgroupAllocationPolicy">SubgroupAllocationPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacederecho.html#ab4f529cba0c6b56c083b5044113b13e3">identical_subgroups_policy</a> (int num_subgroups, const <a class="el" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy">ShardAllocationPolicy</a> &amp;subgroup_policy)</td></tr>
<tr class="memdesc:ab4f529cba0c6b56c083b5044113b13e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="namespacederecho.html#structderecho_1_1SubgroupAllocationPolicy" title="A data structure defining the parameters of the default subgroup allocation function for a single sub...">SubgroupAllocationPolicy</a> for a replicated type that needs n subgroups with identical sharding policies.  <a href="#ab4f529cba0c6b56c083b5044113b13e3">More...</a><br /></td></tr>
<tr class="separator:ab4f529cba0c6b56c083b5044113b13e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fb22ba9a62f85a43c2412a786da630"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a22fb22ba9a62f85a43c2412a786da630"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#a22fb22ba9a62f85a43c2412a786da630">deep_pointer_copy</a> (const std::unique_ptr&lt; T &gt; &amp;to_copy)</td></tr>
<tr class="memdesc:a22fb22ba9a62f85a43c2412a786da630"><td class="mdescLeft">&#160;</td><td class="mdescRight">A copy constructor for objects owned by unique_ptr.  <a href="#a22fb22ba9a62f85a43c2412a786da630">More...</a><br /></td></tr>
<tr class="separator:a22fb22ba9a62f85a43c2412a786da630"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:abff622923a1263e778a2dcdbc07210d2"><td class="memTemplParams" colspan="2">template&lt;typename TargetType , typename... TypePack&gt; </td></tr>
<tr class="memitem:abff622923a1263e778a2dcdbc07210d2"><td class="memTemplItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacederecho.html#abff622923a1263e778a2dcdbc07210d2">index_of_type</a> = <a class="el" href="namespacederecho.html#a1cde0180ea838f8ca4e5cd7b84959c0f">index_of_type_impl</a>&lt;0, TargetType, TypePack...&gt;()</td></tr>
<tr class="memdesc:abff622923a1263e778a2dcdbc07210d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time "function" that computes the index of a type within a template parameter pack of types.  <a href="#abff622923a1263e778a2dcdbc07210d2">More...</a><br /></td></tr>
<tr class="separator:abff622923a1263e778a2dcdbc07210d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structderecho_1_1CallbackSet" id="structderecho_1_1CallbackSet"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structderecho_1_1CallbackSet">&#9670;&nbsp;</a></span>derecho::CallbackSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct derecho::CallbackSet</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Bundles together a set of callback functions for message delivery events. </p>
<p>These will be invoked by <a class="el" href="classderecho_1_1MulticastGroup.html" title="Implements the low-level mechanics of tracking multicasts in a Derecho group, using RDMC to deliver m...">MulticastGroup</a> or <a class="el" href="classderecho_1_1ViewManager.html">ViewManager</a> to hand control back to the client if it wants to implement custom logic to respond to each message's arrival. (Note, this is a client-facing constructor argument, not an internal data structure). </p>

<p class="definition">Definition at line <a class="el" href="multicast__group_8h_source.html#l00039">39</a> of file <a class="el" href="multicast__group_8h_source.html">multicast_group.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a3bb406972d236988040d0dd0f5c15b1b"></a><a class="el" href="namespacederecho.html#ac8624716823ab496a6dd95c15363067a">persistence_callback_t</a></td>
<td class="fieldname">
global_persistence_callback</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aa13f7dc0ed424a8d2389f6ab22e6670a"></a><a class="el" href="namespacederecho.html#a4dd42537160f9d1f1734a20fc81a5d89">message_callback_t</a></td>
<td class="fieldname">
global_stability_callback</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a9554119625a241ffe9c2b11cac9cc305"></a><a class="el" href="namespacederecho.html#ac8624716823ab496a6dd95c15363067a">persistence_callback_t</a></td>
<td class="fieldname">
local_persistence_callback</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structderecho_1_1CrossProductPolicy" id="structderecho_1_1CrossProductPolicy"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structderecho_1_1CrossProductPolicy">&#9670;&nbsp;</a></span>derecho::CrossProductPolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct derecho::CrossProductPolicy</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>An alternate type of subgroup allocation policy for subgroup types whose membership will be defined as a cross-product of other subgroups. </p>

<p class="definition">Definition at line <a class="el" href="subgroup__functions_8h_source.html#l00089">89</a> of file <a class="el" href="subgroup__functions_8h_source.html">subgroup_functions.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="abd192414d1fa90282a4cf0c8bbb5d925"></a>pair&lt; type_index, uint32_t &gt;</td>
<td class="fieldname">
source_subgroup</td>
<td class="fielddoc">
The (type, index) pair identifying the "source" subgroup of the cross-product. <p>Each member of this subgroup will be a sender in T subgroups, where T is the number of shards in the target subgroup. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aff4207a0002ebd2218ab9b2cbe888170"></a>pair&lt; type_index, uint32_t &gt;</td>
<td class="fieldname">
target_subgroup</td>
<td class="fielddoc">
The (type, index) pair identifying the "target" subgroup of the cross-product. <p>Each shard in this subgroup will have all of its members assigned to S subgroups as receivers, where S is the number of members in the source subgroup. </p>
</td></tr>
</table>

</div>
</div>
<a name="structderecho_1_1JoinResponse" id="structderecho_1_1JoinResponse"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structderecho_1_1JoinResponse">&#9670;&nbsp;</a></span>derecho::JoinResponse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct derecho::JoinResponse</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Bundles together a JoinResponseCode and the leader's node ID, which it also needs to send to the new node that wants to join. </p>

<p class="definition">Definition at line <a class="el" href="view__manager_8h_source.html#l00080">80</a> of file <a class="el" href="view__manager_8h_source.html">view_manager.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a9d6f06e1cebeed77b8888cd49f83607e"></a><a class="el" href="namespacederecho.html#a950a5aae55e86f79d1478dd9b142eeb4">JoinResponseCode</a></td>
<td class="fieldname">
code</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a9cc9007490ab7831ba3375b276acc4cf"></a><a class="el" href="derecho__type__definitions_8h.html#a307ecfdca0e28f653d9138dc0f676a77">node_id_t</a></td>
<td class="fieldname">
leader_id</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structderecho_1_1RDMCMessage" id="structderecho_1_1RDMCMessage"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structderecho_1_1RDMCMessage">&#9670;&nbsp;</a></span>derecho::RDMCMessage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct derecho::RDMCMessage</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A structure containing an RDMC message (which consists of some bytes in a registered memory region) and some associated metadata. </p>
<p>Note that the metadata (sender_id, index, etc.) is only stored locally, not sent over the network with the message. </p>

<p class="definition">Definition at line <a class="el" href="multicast__group_8h_source.html#l00141">141</a> of file <a class="el" href="multicast__group_8h_source.html">multicast_group.h</a>.</p>
</div><div class="dynheader">
Collaboration diagram for derecho::RDMCMessage:</div>
<div class="dyncontent">
<div class="center"><img src="structderecho_1_1RDMCMessage__coll__graph.png" border="0" usemap="#derecho_1_1RDMCMessage_coll__map" alt="Collaboration graph"/></div>
<map name="derecho_1_1RDMCMessage_coll__map" id="derecho_1_1RDMCMessage_coll__map">
<area shape="rect" id="node2" href="structderecho_1_1MessageBuffer.html" title="Represents a block of memory used to store a message. " alt="" coords="9,95,173,121"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a6c23321033ddb82083749831b099459c"></a><a class="el" href="namespacederecho.html#a7594bd002094b1ea329f4452fbb9829b">message_id_t</a></td>
<td class="fieldname">
index</td>
<td class="fielddoc">
The message's index (relative to other messages sent by that sender). </td></tr>
<tr><td class="fieldtype">
<a id="a3d08eaece3a11a3d6b6512b2341405a9"></a><a class="el" href="structderecho_1_1MessageBuffer.html">MessageBuffer</a></td>
<td class="fieldname">
message_buffer</td>
<td class="fielddoc">
The <a class="el" href="structderecho_1_1MessageBuffer.html" title="Represents a block of memory used to store a message. ">MessageBuffer</a> that contains the message's body. </td></tr>
<tr><td class="fieldtype">
<a id="a357ffc62bce97c8fecf4b3fc516a4bba"></a>uint32_t</td>
<td class="fieldname">
sender_id</td>
<td class="fielddoc">
The unique node ID of the message's sender. </td></tr>
<tr><td class="fieldtype">
<a id="a051a934aa8474cf1e24620b8ee8af22f"></a>long long unsigned int</td>
<td class="fieldname">
size</td>
<td class="fielddoc">
The message's size in bytes. </td></tr>
</table>

</div>
</div>
<a name="structderecho_1_1ShardAllocationPolicy" id="structderecho_1_1ShardAllocationPolicy"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structderecho_1_1ShardAllocationPolicy">&#9670;&nbsp;</a></span>derecho::ShardAllocationPolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct derecho::ShardAllocationPolicy</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="subgroup__functions_8h_source.html#l00049">49</a> of file <a class="el" href="subgroup__functions_8h_source.html">subgroup_functions.h</a>.</p>
</div><div class="dynheader">
Collaboration diagram for derecho::ShardAllocationPolicy:</div>
<div class="dyncontent">
<div class="center"><img src="structderecho_1_1ShardAllocationPolicy__coll__graph.png" border="0" usemap="#derecho_1_1ShardAllocationPolicy_coll__map" alt="Collaboration graph"/></div>
<map name="derecho_1_1ShardAllocationPolicy_coll__map" id="derecho_1_1ShardAllocationPolicy_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="af9937016875804fb17a38f9936e5387f"></a>bool</td>
<td class="fieldname">
even_shards</td>
<td class="fielddoc">
Whether all shards should contain the same number of members. </td></tr>
<tr><td class="fieldtype">
<a id="ac29d6022564ae7f42224c0c7692fb9cd"></a>vector&lt; <a class="el" href="namespacederecho.html#a1fb14b9518cde9d5f222d1d6039b8bdc">Mode</a> &gt;</td>
<td class="fieldname">
modes_by_shard</td>
<td class="fielddoc">
If even_shards is false, this will contain an entry for each shard indicating which delivery mode it should use. <p>(Ignored if even_shards is true). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a4f767889cf60badb846795ab7de67bf7"></a>int</td>
<td class="fieldname">
nodes_per_shard</td>
<td class="fielddoc">
If even_shards is true, this is the number of nodes per shard. <p>(Ignored if even_shards is false). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a46572ba6f2c16b907eea3f6657c528db"></a>vector&lt; int &gt;</td>
<td class="fieldname">
num_nodes_by_shard</td>
<td class="fielddoc">
If even_shards is false, this will contain an entry for each shard indicating the number of members it should have. <p>(Ignored if even_shards is true). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a43f8cc87760859feffc04a4cff7d514b"></a>int</td>
<td class="fieldname">
num_shards</td>
<td class="fielddoc">
The number of shards; set to 1 for a non-sharded subgroup. </td></tr>
<tr><td class="fieldtype">
<a id="a52dc55bbac35a86967bd82d5f4e2ad24"></a><a class="el" href="namespacederecho.html#a1fb14b9518cde9d5f222d1d6039b8bdc">Mode</a></td>
<td class="fieldname">
shards_mode</td>
<td class="fielddoc">
If even_shards is true, this is the delivery mode that will be used for every shard. <p>(Ignored if even_shards is false). </p>
</td></tr>
</table>

</div>
</div>
<a name="structderecho_1_1SSTMessage" id="structderecho_1_1SSTMessage"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structderecho_1_1SSTMessage">&#9670;&nbsp;</a></span>derecho::SSTMessage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct derecho::SSTMessage</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="multicast__group_8h_source.html#l00153">153</a> of file <a class="el" href="multicast__group_8h_source.html">multicast_group.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a5dc8d57ffad161681ff96fadcd1cc4fe"></a>volatile char *</td>
<td class="fieldname">
buf</td>
<td class="fielddoc">
Pointer to the message. </td></tr>
<tr><td class="fieldtype">
<a id="af649053ebcd0f73c043b905c10a8571a"></a>int32_t</td>
<td class="fieldname">
index</td>
<td class="fielddoc">
The message's index (relative to other messages sent by that sender). </td></tr>
<tr><td class="fieldtype">
<a id="addf3229faa02013308d2100a8ef3d98d"></a>uint32_t</td>
<td class="fieldname">
sender_id</td>
<td class="fielddoc">
The unique node ID of the message's sender. </td></tr>
<tr><td class="fieldtype">
<a id="afe72020da0764e00f3818c6d5aa868ba"></a>long long unsigned int</td>
<td class="fieldname">
size</td>
<td class="fielddoc">
The message's size in bytes. </td></tr>
</table>

</div>
</div>
<a name="structderecho_1_1SubgroupAllocationPolicy" id="structderecho_1_1SubgroupAllocationPolicy"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structderecho_1_1SubgroupAllocationPolicy">&#9670;&nbsp;</a></span>derecho::SubgroupAllocationPolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct derecho::SubgroupAllocationPolicy</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A data structure defining the parameters of the default subgroup allocation function for a single subgroup type. </p>

<p class="definition">Definition at line <a class="el" href="subgroup__functions_8h_source.html#l00074">74</a> of file <a class="el" href="subgroup__functions_8h_source.html">subgroup_functions.h</a>.</p>
</div><div class="dynheader">
Collaboration diagram for derecho::SubgroupAllocationPolicy:</div>
<div class="dyncontent">
<div class="center"><img src="structderecho_1_1SubgroupAllocationPolicy__coll__graph.png" border="0" usemap="#derecho_1_1SubgroupAllocationPolicy_coll__map" alt="Collaboration graph"/></div>
<map name="derecho_1_1SubgroupAllocationPolicy_coll__map" id="derecho_1_1SubgroupAllocationPolicy_coll__map">
<area shape="rect" id="node3" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy" title="derecho::ShardAllocation\lPolicy" alt="" coords="69,95,236,136"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a5083a44e9c17cebecde981ca326f9b99"></a>bool</td>
<td class="fieldname">
identical_subgroups</td>
<td class="fielddoc">
Whether all subgroups of this type will have an identical shard layout. </td></tr>
<tr><td class="fieldtype">
<a id="abd5e9e8ab9c26a0399caeeb347d533a0"></a>int</td>
<td class="fieldname">
num_subgroups</td>
<td class="fielddoc">
The number of subgroups of the same <a class="el" href="classderecho_1_1Replicated.html">Replicated</a> type to create. </td></tr>
<tr><td class="fieldtype">
<a id="a89d4375d47bb271a98502637e6f34040"></a>vector&lt; <a class="el" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy">ShardAllocationPolicy</a> &gt;</td>
<td class="fieldname">
shard_policy_by_subgroup</td>
<td class="fielddoc">
If identical_subgroups is true, contains a single entry with the allocation policy for all subgroups of this type. <p>If identical_subgroups is false, contains an entry for each subgroup describing that subgroup's shards. </p>
</td></tr>
</table>

</div>
</div>
<a name="structderecho_1_1SubgroupSettings" id="structderecho_1_1SubgroupSettings"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structderecho_1_1SubgroupSettings">&#9670;&nbsp;</a></span>derecho::SubgroupSettings</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct derecho::SubgroupSettings</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A collection of settings for a single subgroup that this node is a member of. </p>
<p>Mostly extracted from <a class="el" href="classderecho_1_1SubView.html" title="The subset of a View associated with a single shard, or a single subgroup if the subgroup is non-shar...">SubView</a>, but tailored specifically to what <a class="el" href="classderecho_1_1MulticastGroup.html" title="Implements the low-level mechanics of tracking multicasts in a Derecho group, using RDMC to deliver m...">MulticastGroup</a> needs to know about subgroups and shards. </p>

<p class="definition">Definition at line <a class="el" href="multicast__group_8h_source.html#l00169">169</a> of file <a class="el" href="multicast__group_8h_source.html">multicast_group.h</a>.</p>
</div><div class="dynheader">
Collaboration diagram for derecho::SubgroupSettings:</div>
<div class="dyncontent">
<div class="center"><img src="structderecho_1_1SubgroupSettings__coll__graph.png" border="0" usemap="#derecho_1_1SubgroupSettings_coll__map" alt="Collaboration graph"/></div>
<map name="derecho_1_1SubgroupSettings_coll__map" id="derecho_1_1SubgroupSettings_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="acf6acc920a456fc8e6cca259c36f62ce"></a>vector&lt; <a class="el" href="derecho__type__definitions_8h.html#a307ecfdca0e28f653d9138dc0f676a77">node_id_t</a> &gt;</td>
<td class="fieldname">
members</td>
<td class="fielddoc">
The members of the subgroup. </td></tr>
<tr><td class="fieldtype">
<a id="a207e2e1132efe07d810347b0ffa42368"></a><a class="el" href="namespacederecho.html#a1fb14b9518cde9d5f222d1d6039b8bdc">Mode</a></td>
<td class="fieldname">
mode</td>
<td class="fielddoc">
The operation mode of the subgroup. </td></tr>
<tr><td class="fieldtype">
<a id="a20145822697c7200f69f11e66413ca2b"></a>uint32_t</td>
<td class="fieldname">
num_received_offset</td>
<td class="fielddoc">
The offset of this node's num_received counter within the subgroup's SST section. </td></tr>
<tr><td class="fieldtype">
<a id="a66506932d9296ab777ad123d8ea11223"></a>int</td>
<td class="fieldname">
sender_rank</td>
<td class="fielddoc">
This node's sender rank within the subgroup (as defined by <a class="el" href="classderecho_1_1SubView.html#ab5a0cd1417a0504c179377b5122e69fe" title="Looks up the sender rank of a given member. ">SubView::sender_rank_of</a>) </td></tr>
<tr><td class="fieldtype">
<a id="ae25d3219a23e079ec196274e7502e9ca"></a>vector&lt; int &gt;</td>
<td class="fieldname">
senders</td>
<td class="fielddoc">
The "is_sender" flags for members of the subgroup. </td></tr>
<tr><td class="fieldtype">
<a id="a3d726bbd65cfc1092ad0d0fc7b25f4a7"></a>uint32_t</td>
<td class="fieldname">
shard_num</td>
<td class="fielddoc">
This node's shard number within the subgroup. </td></tr>
<tr><td class="fieldtype">
<a id="a94012b8b0e1821c263baa1c96e8b8beb"></a>uint32_t</td>
<td class="fieldname">
shard_rank</td>
<td class="fielddoc">
This node's rank within its shard of the subgroup. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aa720b56816033b383662e805480cef01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa720b56816033b383662e805480cef01">&#9670;&nbsp;</a></span>contains</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetType , typename... TypePack&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#aa720b56816033b383662e805480cef01">derecho::contains</a> = typedef std::integral_constant&lt;bool, (std::is_same&lt;TargetType, TypePack&gt;::value || ...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type-trait-like template that provides a True member "value" if TargetType matches some type in TypePack (according to std::is_same), or provides a False member "value" if TargetType does not match anything in TypePack. </p>

<p class="definition">Definition at line <a class="el" href="group_8h_source.html#l00064">64</a> of file <a class="el" href="group_8h_source.html">group.h</a>.</p>

</div>
</div>
<a id="a335eb348e6d356901249c74bdf489063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335eb348e6d356901249c74bdf489063">&#9670;&nbsp;</a></span>Factory</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a335eb348e6d356901249c74bdf489063">derecho::Factory</a> = typedef std::function&lt;std::unique_ptr&lt;T&gt;(persistent::PersistentRegistry*)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of factory function the user must provide to the <a class="el" href="classderecho_1_1Group.html" title="The top-level object for creating a Derecho group. ">Group</a> constructor, to construct each <a class="el" href="classderecho_1_1Replicated.html">Replicated</a> Object that is assigned to a subgroup. </p>

<p class="definition">Definition at line <a class="el" href="derecho__internal_8h_source.html#l00048">48</a> of file <a class="el" href="derecho__internal_8h_source.html">derecho_internal.h</a>.</p>

</div>
</div>
<a id="a9ae5633b492f5faf7c9f2bc514ac2d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae5633b492f5faf7c9f2bc514ac2d27">&#9670;&nbsp;</a></span>has_persistent_fields</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a9ae5633b492f5faf7c9f2bc514ac2d27">derecho::has_persistent_fields</a> = typedef std::is_base_of&lt;<a class="el" href="classderecho_1_1PersistsFields.html">PersistsFields</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A template whose member field "value" will be true if type T inherits from <a class="el" href="classderecho_1_1PersistsFields.html" title="This is a marker interface for user-defined Replicated Objects (i.e. ">PersistsFields</a>, and false otherwise. </p>
<p>Just a convenient specialization of std::is_base_of. </p>

<p class="definition">Definition at line <a class="el" href="replicated_8h_source.html#l00046">46</a> of file <a class="el" href="replicated_8h_source.html">replicated.h</a>.</p>

</div>
</div>
<a id="aa0b5717079bf92d1ec04efa8660a327e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b5717079bf92d1ec04efa8660a327e">&#9670;&nbsp;</a></span>lock_guard_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#aa0b5717079bf92d1ec04efa8660a327e">derecho::lock_guard_t</a> = typedef std::lock_guard&lt;std::mutex&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="view__manager_8cpp_source.html#l00020">20</a> of file <a class="el" href="view__manager_8cpp_source.html">view_manager.cpp</a>.</p>

</div>
</div>
<a id="a4dd42537160f9d1f1734a20fc81a5d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd42537160f9d1f1734a20fc81a5d89">&#9670;&nbsp;</a></span>message_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a4dd42537160f9d1f1734a20fc81a5d89">derecho::message_callback_t</a> = typedef std::function&lt;void(<a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a>, <a class="el" href="derecho__type__definitions_8h.html#a307ecfdca0e28f653d9138dc0f676a77">node_id_t</a>, <a class="el" href="namespacederecho.html#a7594bd002094b1ea329f4452fbb9829b">message_id_t</a>, std::optional&lt;std::pair&lt;char*, long long int&gt; &gt;, persistent::version_t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for the type of std::function that is used for message delivery event callbacks. </p>

<p class="definition">Definition at line <a class="el" href="derecho__internal_8h_source.html#l00041">41</a> of file <a class="el" href="derecho__internal_8h_source.html">derecho_internal.h</a>.</p>

</div>
</div>
<a id="a7594bd002094b1ea329f4452fbb9829b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7594bd002094b1ea329f4452fbb9829b">&#9670;&nbsp;</a></span>message_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a7594bd002094b1ea329f4452fbb9829b">derecho::message_id_t</a> = typedef int32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for a message's unique "sequence number" or index. </p>
<p>This allows us to change exactly which numeric type we use to store it. </p>

<p class="definition">Definition at line <a class="el" href="derecho__internal_8h_source.html#l00031">31</a> of file <a class="el" href="derecho__internal_8h_source.html">derecho_internal.h</a>.</p>

</div>
</div>
<a id="ac8624716823ab496a6dd95c15363067a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8624716823ab496a6dd95c15363067a">&#9670;&nbsp;</a></span>persistence_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#ac8624716823ab496a6dd95c15363067a">derecho::persistence_callback_t</a> = typedef std::function&lt;void(<a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a>, persistent::version_t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="derecho__internal_8h_source.html#l00042">42</a> of file <a class="el" href="derecho__internal_8h_source.html">derecho_internal.h</a>.</p>

</div>
</div>
<a id="a1dd25e81ead51e3f21992b9321fc06e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd25e81ead51e3f21992b9321fc06e5">&#9670;&nbsp;</a></span>persistence_manager_callbacks_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a1dd25e81ead51e3f21992b9321fc06e5">derecho::persistence_manager_callbacks_t</a> = typedef std::tuple&lt;<a class="el" href="namespacederecho.html#ae36786abd0a6d38cc803ed6ca06ec887">persistence_manager_make_version_func_t</a>, <a class="el" href="namespacederecho.html#a12df62f91ff8b3d30fe41c983f510f5c">persistence_manager_post_persist_func_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="derecho__internal_8h_source.html#l00059">59</a> of file <a class="el" href="derecho__internal_8h_source.html">derecho_internal.h</a>.</p>

</div>
</div>
<a id="ae36786abd0a6d38cc803ed6ca06ec887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36786abd0a6d38cc803ed6ca06ec887">&#9670;&nbsp;</a></span>persistence_manager_make_version_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#ae36786abd0a6d38cc803ed6ca06ec887">derecho::persistence_manager_make_version_func_t</a> = typedef std::function&lt;void( const <a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a>&amp;, const persistent::version_t&amp;, const HLC&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="derecho__internal_8h_source.html#l00054">54</a> of file <a class="el" href="derecho__internal_8h_source.html">derecho_internal.h</a>.</p>

</div>
</div>
<a id="a12df62f91ff8b3d30fe41c983f510f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12df62f91ff8b3d30fe41c983f510f5c">&#9670;&nbsp;</a></span>persistence_manager_post_persist_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a12df62f91ff8b3d30fe41c983f510f5c">derecho::persistence_manager_post_persist_func_t</a> = typedef std::function&lt;void( const <a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a>&amp;, const persistent::version_t&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="derecho__internal_8h_source.html#l00057">57</a> of file <a class="el" href="derecho__internal_8h_source.html">derecho_internal.h</a>.</p>

</div>
</div>
<a id="a399961c8a9af951d5dc20f468f0e9ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399961c8a9af951d5dc20f468f0e9ad0">&#9670;&nbsp;</a></span>persistence_request_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a399961c8a9af951d5dc20f468f0e9ad0">derecho::persistence_request_t</a> = typedef std::tuple&lt;<a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a>, persistent::version_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="persistence__manager_8h_source.html#l00023">23</a> of file <a class="el" href="persistence__manager_8h_source.html">persistence_manager.h</a>.</p>

</div>
</div>
<a id="ad20e524ab297715d39fcd62eb367ca4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20e524ab297715d39fcd62eb367ca4a">&#9670;&nbsp;</a></span>ragged_trim_map_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#ad20e524ab297715d39fcd62eb367ca4a">derecho::ragged_trim_map_t</a> = typedef std::map&lt;<a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a>, std::map&lt;uint32_t, std::unique_ptr&lt;<a class="el" href="structderecho_1_1RaggedTrim.html">RaggedTrim</a>&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of logged ragged trim states, indexed by (subgroup ID, shard num), stored by pointer. </p>

<p class="definition">Definition at line <a class="el" href="restart__state_8h_source.html#l00054">54</a> of file <a class="el" href="restart__state_8h_source.html">restart_state.h</a>.</p>

</div>
</div>
<a id="aa55bb326016160eb730dc9fe0514c81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55bb326016160eb730dc9fe0514c81c">&#9670;&nbsp;</a></span>replicated_index_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#aa55bb326016160eb730dc9fe0514c81c">derecho::replicated_index_map</a> = typedef std::map&lt;uint32_t, <a class="el" href="classderecho_1_1Replicated.html">Replicated</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="group_8h_source.html#l00068">68</a> of file <a class="el" href="group_8h_source.html">group.h</a>.</p>

</div>
</div>
<a id="a7555b404c6d334bdc241de6bb8534c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7555b404c6d334bdc241de6bb8534c39">&#9670;&nbsp;</a></span>rpc_handler_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a7555b404c6d334bdc241de6bb8534c39">derecho::rpc_handler_t</a> = typedef std::function&lt;void(<a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a>, <a class="el" href="derecho__type__definitions_8h.html#a307ecfdca0e28f653d9138dc0f676a77">node_id_t</a>, char*, uint32_t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="derecho__internal_8h_source.html#l00043">43</a> of file <a class="el" href="derecho__internal_8h_source.html">derecho_internal.h</a>.</p>

</div>
</div>
<a id="a8b27d622f2dc4732352ef110f519ad1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b27d622f2dc4732352ef110f519ad1f">&#9670;&nbsp;</a></span>shard_view_generator_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a8b27d622f2dc4732352ef110f519ad1f">derecho::shard_view_generator_t</a> = typedef std::function&lt;<a class="el" href="namespacederecho.html#a3b0ee73d7d0341de956f33edb2878e20">subgroup_shard_layout_t</a>(const std::type_index&amp;, const std::unique_ptr&lt;<a class="el" href="classderecho_1_1View.html">View</a>&gt;&amp;, <a class="el" href="classderecho_1_1View.html">View</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a lambda function that generates subgroup and shard views for a specific subgroup type. </p>
<p>This is a function that takes the previous <a class="el" href="classderecho_1_1View.html">View</a> and current <a class="el" href="classderecho_1_1View.html">View</a> as input, and outputs a vector-of-vectors representing subgroups and shards. </p>

<p class="definition">Definition at line <a class="el" href="subgroup__info_8h_source.html#l00049">49</a> of file <a class="el" href="subgroup__info_8h_source.html">subgroup_info.h</a>.</p>

</div>
</div>
<a id="aff2cd00140eaa031b4056c2c51caef18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2cd00140eaa031b4056c2c51caef18">&#9670;&nbsp;</a></span>shared_lock_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#aff2cd00140eaa031b4056c2c51caef18">derecho::shared_lock_t</a> = typedef std::shared_lock&lt;std::shared_timed_mutex&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="view__manager_8cpp_source.html#l00022">22</a> of file <a class="el" href="view__manager_8cpp_source.html">view_manager.cpp</a>.</p>

</div>
</div>
<a id="ab9d358a67fa805be8a898a6e19f3e225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d358a67fa805be8a898a6e19f3e225">&#9670;&nbsp;</a></span>SharedLockedReference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#ab9d358a67fa805be8a898a6e19f3e225">derecho::SharedLockedReference</a> = typedef <a class="el" href="classderecho_1_1LockedReference.html">LockedReference</a>&lt;std::shared_lock&lt;std::shared_timed_mutex&gt;, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="view__manager_8h_source.html#l00086">86</a> of file <a class="el" href="view__manager_8h_source.html">view_manager.h</a>.</p>

</div>
</div>
<a id="a5166c1baf8aaf072658901fa0ec4e06d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5166c1baf8aaf072658901fa0ec4e06d">&#9670;&nbsp;</a></span>subgroup_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">derecho::subgroup_id_t</a> = typedef uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for the internal Subgroup IDs generated by <a class="el" href="classderecho_1_1ViewManager.html">ViewManager</a>. </p>
<p>This allows us to change exactly which numeric type we use to store it. </p>

<p class="definition">Definition at line <a class="el" href="derecho__internal_8h_source.html#l00028">28</a> of file <a class="el" href="derecho__internal_8h_source.html">derecho_internal.h</a>.</p>

</div>
</div>
<a id="a2e4d4017445fcee3d6976dc21260e36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4d4017445fcee3d6976dc21260e36e">&#9670;&nbsp;</a></span>subgroup_post_next_version_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a2e4d4017445fcee3d6976dc21260e36e">derecho::subgroup_post_next_version_func_t</a> = typedef std::function&lt;void( const <a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a>&amp;, const persistent::version_t&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="derecho__internal_8h_source.html#l00064">64</a> of file <a class="el" href="derecho__internal_8h_source.html">derecho_internal.h</a>.</p>

</div>
</div>
<a id="a3b0ee73d7d0341de956f33edb2878e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0ee73d7d0341de956f33edb2878e20">&#9670;&nbsp;</a></span>subgroup_shard_layout_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a3b0ee73d7d0341de956f33edb2878e20">derecho::subgroup_shard_layout_t</a> = typedef std::vector&lt;std::vector&lt;<a class="el" href="classderecho_1_1SubView.html">SubView</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The data structure used to store a subgroups-and-shards layout for a single subgroup type (i.e. </p>
<p><a class="el" href="classderecho_1_1Replicated.html">Replicated</a> Object type). The outer vector represents subgroups of the same type, and the inner vector represents shards of each subgroup, so the vectors map subgroup index -&gt; shard index -&gt; sub-view of that shard. </p>

<p class="definition">Definition at line <a class="el" href="subgroup__info_8h_source.html#l00043">43</a> of file <a class="el" href="subgroup__info_8h_source.html">subgroup_info.h</a>.</p>

</div>
</div>
<a id="ada5e9c5fbee4788f4451aa097bb75ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5e9c5fbee4788f4451aa097bb75ea2">&#9670;&nbsp;</a></span>subgroup_type_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#ada5e9c5fbee4788f4451aa097bb75ea2">derecho::subgroup_type_id_t</a> = typedef uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the numeric ID used to refer to subgroup types within a <a class="el" href="classderecho_1_1Group.html" title="The top-level object for creating a Derecho group. ">Group</a>; this is currently computed as the index of the subgroup type within <a class="el" href="classderecho_1_1Group.html" title="The top-level object for creating a Derecho group. ">Group</a>'s template parameters. </p>

<p class="definition">Definition at line <a class="el" href="derecho__internal_8h_source.html#l00037">37</a> of file <a class="el" href="derecho__internal_8h_source.html">derecho_internal.h</a>.</p>

</div>
</div>
<a id="ae6c56618eccc62191c8504856cfd9d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c56618eccc62191c8504856cfd9d18">&#9670;&nbsp;</a></span>unique_lock_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#ae6c56618eccc62191c8504856cfd9d18">derecho::unique_lock_t</a> = typedef std::unique_lock&lt;std::mutex&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="view__manager_8cpp_source.html#l00021">21</a> of file <a class="el" href="view__manager_8cpp_source.html">view_manager.cpp</a>.</p>

</div>
</div>
<a id="a9f35a3df9a34d833d6e17643028ce2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f35a3df9a34d833d6e17643028ce2cd">&#9670;&nbsp;</a></span>vector_int64_2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a9f35a3df9a34d833d6e17643028ce2cd">derecho::vector_int64_2d</a> = typedef std::vector&lt;std::vector&lt;int64_t&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of a 2-dimensional vector used to store potential node IDs, or -1. </p>

<p class="definition">Definition at line <a class="el" href="view__manager_8h_source.html#l00091">91</a> of file <a class="el" href="view__manager_8h_source.html">view_manager.h</a>.</p>

</div>
</div>
<a id="a8847e67ac70cd55aa5114fc3294aa326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8847e67ac70cd55aa5114fc3294aa326">&#9670;&nbsp;</a></span>view_upcall_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacederecho.html#a8847e67ac70cd55aa5114fc3294aa326">derecho::view_upcall_t</a> = typedef std::function&lt;void(const <a class="el" href="classderecho_1_1View.html">View</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="view__manager_8h_source.html#l00088">88</a> of file <a class="el" href="view__manager_8h_source.html">view_manager.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a3eda31de4dd1e1caa4329b6e3175f17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eda31de4dd1e1caa4329b6e3175f17e">&#9670;&nbsp;</a></span>CommitMessage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacederecho.html#a3eda31de4dd1e1caa4329b6e3175f17e">derecho::CommitMessage</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A type-safe set of messages that can be sent during two-phase commit. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3eda31de4dd1e1caa4329b6e3175f17eab205205bc58adbefd02d8ba357b9c57f"></a>PREPARE&#160;</td><td class="fielddoc"><p>PREPARE. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3eda31de4dd1e1caa4329b6e3175f17ea1d0ba376e273b9d622641124d8c59264"></a>COMMIT&#160;</td><td class="fielddoc"><p>COMMIT. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3eda31de4dd1e1caa4329b6e3175f17ea8d12a2ca7e5a64036d7251a3eda51a38"></a>ABORT&#160;</td><td class="fielddoc"><p>ABORT. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="restart__state_8h_source.html#l00038">38</a> of file <a class="el" href="restart__state_8h_source.html">restart_state.h</a>.</p>

</div>
</div>
<a id="a950a5aae55e86f79d1478dd9b142eeb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950a5aae55e86f79d1478dd9b142eeb4">&#9670;&nbsp;</a></span>JoinResponseCode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacederecho.html#a950a5aae55e86f79d1478dd9b142eeb4">derecho::JoinResponseCode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A set of status codes the group leader can respond with upon initially receiving a connection request from a new node. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a950a5aae55e86f79d1478dd9b142eeb4ae0aa021e21dddbd6d8cecec71e9cf564"></a>OK&#160;</td><td class="fielddoc"><p>OK The new member can proceed to join as normal. </p>
</td></tr>
<tr><td class="fieldname"><a id="a950a5aae55e86f79d1478dd9b142eeb4a556cec21aa265c82893003ac91c61546"></a>TOTAL_RESTART&#160;</td><td class="fielddoc"><p>TOTAL_RESTART The group is currently restarting from a total failure, so the new member should send its logged view and ragged trim. </p>
</td></tr>
<tr><td class="fieldname"><a id="a950a5aae55e86f79d1478dd9b142eeb4a7bcc2a64209055d2ab40018c53bc9a03"></a>ID_IN_USE&#160;</td><td class="fielddoc"><p>ID_IN_USE The node's ID is already listed as a member of the current view, so it can't join. </p>
</td></tr>
<tr><td class="fieldname"><a id="a950a5aae55e86f79d1478dd9b142eeb4afc1ba884b5e3854e267da6f7c40bb48b"></a>LEADER_REDIRECT&#160;</td><td class="fielddoc"><p>LEADER_REDIRECT This node is not actually the leader and can't accept a join. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="view__manager_8h_source.html#l00069">69</a> of file <a class="el" href="view__manager_8h_source.html">view_manager.h</a>.</p>

</div>
</div>
<a id="a1fb14b9518cde9d5f222d1d6039b8bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb14b9518cde9d5f222d1d6039b8bdc">&#9670;&nbsp;</a></span>Mode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacederecho.html#a1fb14b9518cde9d5f222d1d6039b8bdc">derecho::Mode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1fb14b9518cde9d5f222d1d6039b8bdcaabc458a817b34b4750413b587f536ac0"></a>ORDERED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1fb14b9518cde9d5f222d1d6039b8bdca6caf8ac543ee5994b1ab98021bba1173"></a>UNORDERED&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="derecho__modes_8h_source.html#l00004">4</a> of file <a class="el" href="derecho__modes_8h_source.html">derecho_modes.h</a>.</p>

</div>
</div>
<a id="a9128f4ac3ce2a84c9f7c7b5503378a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9128f4ac3ce2a84c9f7c7b5503378a12">&#9670;&nbsp;</a></span>PORT_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacederecho.html#a9128f4ac3ce2a84c9f7c7b5503378a12">derecho::PORT_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9128f4ac3ce2a84c9f7c7b5503378a12a2daba9851f81b62e00558f5f96447544"></a>GMS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9128f4ac3ce2a84c9f7c7b5503378a12a296275e810353ddb092cabc68edbe31a"></a>RPC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9128f4ac3ce2a84c9f7c7b5503378a12affb3ca023a136b181de997dacdec756d"></a>SST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9128f4ac3ce2a84c9f7c7b5503378a12a0f1617776c11aca5e387e135371a48df"></a>RDMC&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="view_8h_source.html#l00022">22</a> of file <a class="el" href="view_8h_source.html">view.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a136390448e35fec19f72933c9bcdef80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136390448e35fec19f72933c9bcdef80">&#9670;&nbsp;</a></span>__attribute__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct derecho::__attribute__ </td>
          <td>(</td>
          <td class="paramtype">(__packed__)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The header for an individual multicast message, which will always be the first sizeof(header) bytes in the message's data buffer. </p>

<p class="definition">Definition at line <a class="el" href="multicast__group_8h_source.html#l00105">105</a> of file <a class="el" href="multicast__group_8h_source.html">multicast_group.h</a>.</p>

</div>
</div>
<a id="afea7b838acf6fc6bf2e54dd886c2cb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea7b838acf6fc6bf2e54dd886c2cb7b">&#9670;&nbsp;</a></span>custom_shards_policy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy">ShardAllocationPolicy</a> derecho::custom_shards_policy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>num_nodes_by_shard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacederecho.html#a1fb14b9518cde9d5f222d1d6039b8bdc">Mode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>delivery_modes_by_shard</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy">ShardAllocationPolicy</a> for a subgroup that has a different number of members in each shard, and possibly has each shard in a different delivery mode. </p>
<p>Note that the two parameter vectors must be the same length. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_nodes_by_shard</td><td>A vector specifying how many nodes should be in each shard; the ith shard will have num_nodes_by_shard[i] members. </td></tr>
    <tr><td class="paramname">delivery_modes_by_shard</td><td>A vector specifying the delivery mode (Raw or Ordered) for each shard, in the same order as the other vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy">ShardAllocationPolicy</a> that specifies these shard sizes and modes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subgroup__functions_8cpp_source.html#l00040">40</a> of file <a class="el" href="subgroup__functions_8cpp_source.html">subgroup_functions.cpp</a>.</p>

</div>
</div>
<a id="a22fb22ba9a62f85a43c2412a786da630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22fb22ba9a62f85a43c2412a786da630">&#9670;&nbsp;</a></span>deep_pointer_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;T&gt; derecho::deep_pointer_copy </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>to_copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A copy constructor for objects owned by unique_ptr. </p>
<p>Does the obvious thing and invokes the copy constructor of the object being pointed to, or returns nullptr if the unique_ptr is empty. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_copy</td><td>A unique_ptr to the object to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new object in a new unique_ptr that is a copy of the old object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subgroup__functions_8h_source.html#l00026">26</a> of file <a class="el" href="subgroup__functions_8h_source.html">subgroup_functions.h</a>.</p>

</div>
</div>
<a id="a0243871e8d5df1613d3fdde7a34af9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0243871e8d5df1613d3fdde7a34af9f7">&#9670;&nbsp;</a></span>even_sharding_policy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy">ShardAllocationPolicy</a> derecho::even_sharding_policy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_shards</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodes_per_shard</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy">ShardAllocationPolicy</a> that specifies num_shards shards with the same number of nodes in each shard. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_shards</td><td>The number of shards to request in this policy. </td></tr>
    <tr><td class="paramname">nodes_per_shard</td><td>The number of nodes per shard to request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy">ShardAllocationPolicy</a> value with these parameters. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subgroup__functions_8cpp_source.html#l00032">32</a> of file <a class="el" href="subgroup__functions_8cpp_source.html">subgroup_functions.cpp</a>.</p>

</div>
</div>
<a id="ada9f13b79bd4400e58b85629b9c97f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9f13b79bd4400e58b85629b9c97f13">&#9670;&nbsp;</a></span>functional_append() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; derecho::functional_append </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base case for functional_append, with one argument. </p>

<p class="definition">Definition at line <a class="el" href="container__template__functions_8h_source.html#l00034">34</a> of file <a class="el" href="container__template__functions_8h_source.html">container_template_functions.h</a>.</p>

</div>
</div>
<a id="a8638b3b0dab113f03fe666ae15653f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8638b3b0dab113f03fe666ae15653f01">&#9670;&nbsp;</a></span>functional_append() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... RestArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; derecho::functional_append </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>first_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestArgs...&#160;</td>
          <td class="paramname"><em>rest_items</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new std::vector value that is equal to the parameter std::vector with the rest of the arguments appended. </p>
<p>Adds some missing functionality to std::vector: the ability to append to a const vector without taking a several-line detour to call the void emplace_back() method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>The vector that should be the prefix of the new vector </td></tr>
    <tr><td class="paramname">first_item</td><td>The first element to append to the original vector </td></tr>
    <tr><td class="paramname">rest_items</td><td>The rest of the elements to append to the original vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new vector (by value), containing a copy of original plus all the elements given as arguments. </dd></dl>

<p class="definition">Definition at line <a class="el" href="container__template__functions_8h_source.html#l00052">52</a> of file <a class="el" href="container__template__functions_8h_source.html">container_template_functions.h</a>.</p>

</div>
</div>
<a id="a101760596625ad156d376a886a24a86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101760596625ad156d376a886a24a86a">&#9670;&nbsp;</a></span>functional_insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;T&gt; derecho::functional_insert </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts set b into set a and returns the modified a. </p>
<p>Hack to get around the fact that set::insert doesn't return *this. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The set to modify and return </td></tr>
    <tr><td class="paramname">b</td><td>The set that should be inserted into a. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Set a. </dd></dl>

<p class="definition">Definition at line <a class="el" href="container__template__functions_8h_source.html#l00025">25</a> of file <a class="el" href="container__template__functions_8h_source.html">container_template_functions.h</a>.</p>

</div>
</div>
<a id="ae71ddbb2248f79d945b580442aef0855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71ddbb2248f79d945b580442aef0855">&#9670;&nbsp;</a></span>getConfBoolean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool derecho::getConfBoolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conf_8cpp_source.html#l00129">129</a> of file <a class="el" href="conf_8cpp_source.html">conf.cpp</a>.</p>

</div>
</div>
<a id="aa5fafd7ffbc928b499f28db6b88e55fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5fafd7ffbc928b499f28db6b88e55fb">&#9670;&nbsp;</a></span>getConfDouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double derecho::getConfDouble </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conf_8cpp_source.html#l00125">125</a> of file <a class="el" href="conf_8cpp_source.html">conf.cpp</a>.</p>

</div>
</div>
<a id="addab4baa5299eac871a6c018e5f58bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addab4baa5299eac871a6c018e5f58bd9">&#9670;&nbsp;</a></span>getConfFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float derecho::getConfFloat </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conf_8cpp_source.html#l00121">121</a> of file <a class="el" href="conf_8cpp_source.html">conf.cpp</a>.</p>

</div>
</div>
<a id="a3985963f9c358dab086d964cccf609fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3985963f9c358dab086d964cccf609fb">&#9670;&nbsp;</a></span>getConfInt16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int16_t derecho::getConfInt16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conf_8cpp_source.html#l00105">105</a> of file <a class="el" href="conf_8cpp_source.html">conf.cpp</a>.</p>

</div>
</div>
<a id="aa0e4c6d00f3d763914f45c779f922f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e4c6d00f3d763914f45c779f922f32">&#9670;&nbsp;</a></span>getConfInt32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t derecho::getConfInt32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conf_8cpp_source.html#l00097">97</a> of file <a class="el" href="conf_8cpp_source.html">conf.cpp</a>.</p>

</div>
</div>
<a id="a4d13b01722e150a804d2b6446dedc47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d13b01722e150a804d2b6446dedc47b">&#9670;&nbsp;</a></span>getConfInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int64_t derecho::getConfInt64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conf_8cpp_source.html#l00113">113</a> of file <a class="el" href="conf_8cpp_source.html">conf.cpp</a>.</p>

</div>
</div>
<a id="a21d9651d962300c3c8119413eb159423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d9651d962300c3c8119413eb159423">&#9670;&nbsp;</a></span>getConfString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; derecho::getConfString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conf_8cpp_source.html#l00093">93</a> of file <a class="el" href="conf_8cpp_source.html">conf.cpp</a>.</p>

</div>
</div>
<a id="ae7758c7071c03e509d7f9a434a521585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7758c7071c03e509d7f9a434a521585">&#9670;&nbsp;</a></span>getConfUInt16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint16_t derecho::getConfUInt16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conf_8cpp_source.html#l00109">109</a> of file <a class="el" href="conf_8cpp_source.html">conf.cpp</a>.</p>

</div>
</div>
<a id="a3c26a899c4a6d5b4139f74276db2a521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c26a899c4a6d5b4139f74276db2a521">&#9670;&nbsp;</a></span>getConfUInt32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t derecho::getConfUInt32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conf_8cpp_source.html#l00101">101</a> of file <a class="el" href="conf_8cpp_source.html">conf.cpp</a>.</p>

</div>
</div>
<a id="a83a7e827260bb1a773cc4de67ad65028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a7e827260bb1a773cc4de67ad65028">&#9670;&nbsp;</a></span>getConfUInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint64_t derecho::getConfUInt64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conf_8cpp_source.html#l00117">117</a> of file <a class="el" href="conf_8cpp_source.html">conf.cpp</a>.</p>

</div>
</div>
<a id="a1ea4422a6dc28bd2d7cbc61852855e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea4422a6dc28bd2d7cbc61852855e91">&#9670;&nbsp;</a></span>hasCustomizedConfKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool derecho::hasCustomizedConfKey </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conf_8cpp_source.html#l00133">133</a> of file <a class="el" href="conf_8cpp_source.html">conf.cpp</a>.</p>

</div>
</div>
<a id="ab4f529cba0c6b56c083b5044113b13e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f529cba0c6b56c083b5044113b13e3">&#9670;&nbsp;</a></span>identical_subgroups_policy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacederecho.html#structderecho_1_1SubgroupAllocationPolicy">SubgroupAllocationPolicy</a> derecho::identical_subgroups_policy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_subgroups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy">ShardAllocationPolicy</a> &amp;&#160;</td>
          <td class="paramname"><em>subgroup_policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="namespacederecho.html#structderecho_1_1SubgroupAllocationPolicy" title="A data structure defining the parameters of the default subgroup allocation function for a single sub...">SubgroupAllocationPolicy</a> for a replicated type that needs n subgroups with identical sharding policies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_subgroups</td><td>The number of subgroups to create. </td></tr>
    <tr><td class="paramname">subgroup_policy</td><td>The policy to use for sharding each subgroup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="namespacederecho.html#structderecho_1_1SubgroupAllocationPolicy" title="A data structure defining the parameters of the default subgroup allocation function for a single sub...">SubgroupAllocationPolicy</a> for a replicated type with num_subgroups copies of the same subgroup. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subgroup__functions_8cpp_source.html#l00050">50</a> of file <a class="el" href="subgroup__functions_8cpp_source.html">subgroup_functions.cpp</a>.</p>

</div>
</div>
<a id="a6323c39d344380e5859dd390856c7ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6323c39d344380e5859dd390856c7ea4">&#9670;&nbsp;</a></span>index_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t derecho::index_of </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to find the index of an element in a container. </p>

<p class="definition">Definition at line <a class="el" href="multicast__group_8cpp_source.html#l00019">19</a> of file <a class="el" href="multicast__group_8cpp_source.html">multicast_group.cpp</a>.</p>

</div>
</div>
<a id="acf60bf445567e2de3aab74a3c7092cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf60bf445567e2de3aab74a3c7092cc1">&#9670;&nbsp;</a></span>index_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t derecho::index_of </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Container::value_type &amp;&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a value in a STL container, and returns the index of that value in the container. </p>
<p>This simply combines std::find (which returns an opaque pointer to the found value) with std::distance (which converts the pointer to a numeric index). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>An STL container, which must provide a member type value_type </td></tr>
    <tr><td class="paramname">elem</td><td>An element of type value_type to search for in the container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the element within the container, or 1 greater than the size of the container if the element was not found. </dd></dl>

<p class="definition">Definition at line <a class="el" href="container__template__functions_8h_source.html#l00099">99</a> of file <a class="el" href="container__template__functions_8h_source.html">container_template_functions.h</a>.</p>

</div>
</div>
<a id="a1cde0180ea838f8ca4e5cd7b84959c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cde0180ea838f8ca4e5cd7b84959c0f">&#9670;&nbsp;</a></span>index_of_type_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint32_t counter, typename TargetType , typename FirstType , typename... RestTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t derecho::index_of_type_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function that implements index_of_type, which is separate to hide the "counter" template parameter (an implementation detail only used to maintain state across recursive calls). </p>

<p class="definition">Definition at line <a class="el" href="group_8h_source.html#l00040">40</a> of file <a class="el" href="group_8h_source.html">group.h</a>.</p>

</div>
</div>
<a id="a1ff5fa530d9a8219fc5c5dd69a7c89a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff5fa530d9a8219fc5c5dd69a7c89a8">&#9670;&nbsp;</a></span>keys_as_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;K&gt; derecho::keys_as_list </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a std::list of the keys in a std::map, in the same order as they appear in the std::map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A std::map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::list containing a copy of each key in the map, in the same order </dd></dl>

<p class="definition">Definition at line <a class="el" href="container__template__functions_8h_source.html#l00080">80</a> of file <a class="el" href="container__template__functions_8h_source.html">container_template_functions.h</a>.</p>

</div>
</div>
<a id="a7a4ed687e994d00b37422107ffc38204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4ed687e994d00b37422107ffc38204">&#9670;&nbsp;</a></span>kind_map_builder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MapType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void derecho::kind_map_builder </td>
          <td>(</td>
          <td class="paramtype">MapType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="make__kind__map_8h_source.html#l00017">17</a> of file <a class="el" href="make__kind__map_8h_source.html">make_kind_map.h</a>.</p>

</div>
</div>
<a id="a2da328941ec7107e38b82de353ab326a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da328941ec7107e38b82de353ab326a">&#9670;&nbsp;</a></span>kind_map_builder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MapType , typename FirstType , typename... RestTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void derecho::kind_map_builder </td>
          <td>(</td>
          <td class="paramtype">MapType &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacederecho.html#a335eb348e6d356901249c74bdf489063">Factory</a>&lt; FirstType &gt;&#160;</td>
          <td class="paramname"><em>curr_factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacederecho.html#a335eb348e6d356901249c74bdf489063">Factory</a>&lt; RestTypes &gt;...&#160;</td>
          <td class="paramname"><em>rest_factories</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Actual implementation of make_kind_map; needs to be a separate function because the only way to build a KindMap is with a void mutator function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A mutable reference to the KindMap being constructed </td></tr>
    <tr><td class="paramname">curr_factory</td><td>The first factory in the parameter pack of factories </td></tr>
    <tr><td class="paramname">rest_factories</td><td>The rest of the parameter pack </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="make__kind__map_8h_source.html#l00027">27</a> of file <a class="el" href="make__kind__map_8h_source.html">make_kind_map.h</a>.</p>

</div>
</div>
<a id="a41ad962d14dcfbe9f3066656742b2552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ad962d14dcfbe9f3066656742b2552">&#9670;&nbsp;</a></span>make_kind_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mutils::KindMap&lt;<a class="el" href="namespacederecho.html#a335eb348e6d356901249c74bdf489063">Factory</a>, Types...&gt; derecho::make_kind_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacederecho.html#a335eb348e6d356901249c74bdf489063">Factory</a>&lt; Types &gt;...&#160;</td>
          <td class="paramname"><em>factories</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a KindMap&lt;Factory, Types...&gt; from a list of factories of those types. </p>
<p>Could probably be made even more generic, to construct a KindMap of any template given a list of objects that match that template, but that would involve writing a template template parameter, which is too much black magic for me to understand. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factories</td><td>One instance of Factory&lt;T&gt; for each T in the type list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A KindMap of factories, mapping each type to a Factory for that type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="make__kind__map_8h_source.html#l00043">43</a> of file <a class="el" href="make__kind__map_8h_source.html">make_kind_map.h</a>.</p>

</div>
</div>
<a id="a560af875aa85bcc7ff733d46181b7f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a560af875aa85bcc7ff733d46181b7f15">&#9670;&nbsp;</a></span>make_next_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classderecho_1_1View.html">View</a> &gt; derecho::make_next_view </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classderecho_1_1View.html">View</a> &amp;&#160;</td>
          <td class="paramname"><em>curr_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>leave_ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="derecho__type__definitions_8h.html#a307ecfdca0e28f653d9138dc0f676a77">node_id_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>joiner_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; <a class="el" href="derecho__type__definitions_8h.html#ab11e09092fcdbb0202a500479b3939b4">ip_addr_t</a>, uint16_t, uint16_t, uint16_t, uint16_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>joiner_ips_and_ports</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the next <a class="el" href="classderecho_1_1View.html">View</a> given the current <a class="el" href="classderecho_1_1View.html">View</a> and the set of failures and joins. </p>
<p>Uses exactly the same logic as the "initialize the next view" section of the start_view_change predicate, with the crucial difference that retrieving the joiner IPs from the SST has been stripped out (the joiner IPs are assumed to be known already) so that it doesn't need an SST to run correctly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curr_view</td><td>The current <a class="el" href="classderecho_1_1View.html">View</a> </td></tr>
    <tr><td class="paramname">leave_ranks</td><td>The ranks (in the current <a class="el" href="classderecho_1_1View.html">View</a>'s members list) of members that are leaving </td></tr>
    <tr><td class="paramname">joiner_ids</td><td>The IDs of new nodes that are joining </td></tr>
    <tr><td class="paramname">joiner_ips</td><td>The IP addresses of the new nodes that are joining, in the same order as their corresponding IDs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classderecho_1_1View.html">View</a> with the joins and leaves applied </dd></dl>

<p class="definition">Definition at line <a class="el" href="subgroup__function__tester_8cpp_source.html#l00187">187</a> of file <a class="el" href="subgroup__function__tester_8cpp_source.html">subgroup_function_tester.cpp</a>.</p>

</div>
</div>
<a id="a005ecde09c73e873a687e9a573f2cd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005ecde09c73e873a687e9a573f2cd53">&#9670;&nbsp;</a></span>multimap_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K1 , typename K2 , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t derecho::multimap_size </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; K1, std::map&lt; K2, V &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>multimap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of a std::map of std::maps, by counting up the sizes of all the inner maps. </p>
<p>Sort of a "deep size" for the common case of a map-of-maps. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multimap</td><td>A map of maps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of elements in the std::map, counting all the elements in all the "inner" std::maps. </dd></dl>

<p class="definition">Definition at line <a class="el" href="container__template__functions_8h_source.html#l00065">65</a> of file <a class="el" href="container__template__functions_8h_source.html">container_template_functions.h</a>.</p>

</div>
</div>
<a id="a1857f085d6fa99a39d172204c13a6e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1857f085d6fa99a39d172204c13a6e5e">&#9670;&nbsp;</a></span>one_subgroup_entire_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacederecho.html#a3b0ee73d7d0341de956f33edb2878e20">subgroup_shard_layout_t</a> derecho::one_subgroup_entire_view </td>
          <td>(</td>
          <td class="paramtype">const std::type_index &amp;&#160;</td>
          <td class="paramname"><em>subgroup_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; <a class="el" href="classderecho_1_1View.html">View</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>prev_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classderecho_1_1View.html">View</a> &amp;&#160;</td>
          <td class="paramname"><em>curr_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple implementation of shard_view_generator_t that returns a single, un-sharded subgroup containing all the members of curr_view, regardless of what subgroup type is supplied. </p>
<p>This is best used when there is only one subgroup type. </p>

<p class="definition">Definition at line <a class="el" href="subgroup__functions_8cpp_source.html#l00017">17</a> of file <a class="el" href="subgroup__functions_8cpp_source.html">subgroup_functions.cpp</a>.</p>

</div>
</div>
<a id="a9d60246631954534874da5fc4a8a0d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d60246631954534874da5fc4a8a0d80">&#9670;&nbsp;</a></span>one_subgroup_entire_view_raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacederecho.html#a3b0ee73d7d0341de956f33edb2878e20">subgroup_shard_layout_t</a> derecho::one_subgroup_entire_view_raw </td>
          <td>(</td>
          <td class="paramtype">const std::type_index &amp;&#160;</td>
          <td class="paramname"><em>subgroup_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; <a class="el" href="classderecho_1_1View.html">View</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>prev_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classderecho_1_1View.html">View</a> &amp;&#160;</td>
          <td class="paramname"><em>curr_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple implementation of shard_view_generator_t that returns a single, un-sharded subgroup in Unordered (Raw) mode containing all the members of curr_view, regardless of what subgroup type is supplied. </p>
<p>This is best used when there is only one subgroup type. </p>

<p class="definition">Definition at line <a class="el" href="subgroup__functions_8cpp_source.html#l00024">24</a> of file <a class="el" href="subgroup__functions_8cpp_source.html">subgroup_functions.cpp</a>.</p>

</div>
</div>
<a id="a7e8bf92a5d64fa9fb186b9bc71c79ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8bf92a5d64fa9fb186b9bc71c79ece">&#9670;&nbsp;</a></span>one_subgroup_policy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacederecho.html#structderecho_1_1SubgroupAllocationPolicy">SubgroupAllocationPolicy</a> derecho::one_subgroup_policy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy">ShardAllocationPolicy</a> &amp;&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="namespacederecho.html#structderecho_1_1SubgroupAllocationPolicy" title="A data structure defining the parameters of the default subgroup allocation function for a single sub...">SubgroupAllocationPolicy</a> for a replicated type that only has a single subgroup. </p>
<p>The <a class="el" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy">ShardAllocationPolicy</a> argument can be the result of one of the <a class="el" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy">ShardAllocationPolicy</a> helper functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>The allocation policy to use for the single subgroup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="namespacederecho.html#structderecho_1_1SubgroupAllocationPolicy" title="A data structure defining the parameters of the default subgroup allocation function for a single sub...">SubgroupAllocationPolicy</a> for a single-subgroup type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subgroup__functions_8cpp_source.html#l00046">46</a> of file <a class="el" href="subgroup__functions_8cpp_source.html">subgroup_functions.cpp</a>.</p>

</div>
</div>
<a id="acc1bc9c5ac5e6c171fbb07a6c745d230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1bc9c5ac5e6c171fbb07a6c745d230">&#9670;&nbsp;</a></span>print_subgroup_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void derecho::print_subgroup_layout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacederecho.html#a3b0ee73d7d0341de956f33edb2878e20">subgroup_shard_layout_t</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the membership of a subgroup/shard layout to stdout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layout</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="subgroup__function__tester_8cpp_source.html#l00114">114</a> of file <a class="el" href="subgroup__function__tester_8cpp_source.html">subgroup_function_tester.cpp</a>.</p>

</div>
</div>
<a id="ade7e60886bce957926410b3692a4488a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7e60886bce957926410b3692a4488a">&#9670;&nbsp;</a></span>ragged_trim_filename()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string derecho::ragged_trim_filename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacederecho.html#a5166c1baf8aaf072658901fa0ec4e06d">subgroup_id_t</a>&#160;</td>
          <td class="paramname"><em>subgroup_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>shard_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a filename to use for a <a class="el" href="structderecho_1_1RaggedTrim.html" title="Represents the data needed to log a &quot;ragged trim&quot; decision to disk. ">RaggedTrim</a> logged to disk using its subgroup and shard IDs. </p>

<p class="definition">Definition at line <a class="el" href="restart__state_8h_source.html#l00047">47</a> of file <a class="el" href="restart__state_8h_source.html">restart_state.h</a>.</p>

</div>
</div>
<a id="ab2cfda95d10697c3ce56bd9a041579cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2cfda95d10697c3ce56bd9a041579cc">&#9670;&nbsp;</a></span>raw_even_sharding_policy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy">ShardAllocationPolicy</a> derecho::raw_even_sharding_policy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_shards</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodes_per_shard</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy">ShardAllocationPolicy</a> that specifies num_shards shards with the same number of nodes in each shard, and every shard running in "raw" delivery mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_shards</td><td>The number of shards to request in this policy. </td></tr>
    <tr><td class="paramname">nodes_per_shard</td><td>The number of nodes per shard to request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="namespacederecho.html#structderecho_1_1ShardAllocationPolicy">ShardAllocationPolicy</a> value with these parameters. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subgroup__functions_8cpp_source.html#l00036">36</a> of file <a class="el" href="subgroup__functions_8cpp_source.html">subgroup_functions.cpp</a>.</p>

</div>
</div>
<a id="a972ce05a66dc751eebde761e9cde76d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972ce05a66dc751eebde761e9cde76d5">&#9670;&nbsp;</a></span>raw_object_factory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="structderecho_1_1RawObject.html">RawObject</a>&gt; derecho::raw_object_factory </td>
          <td>(</td>
          <td class="paramtype">PersistentRegistry *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An implementation of Factory&lt;T&gt; for <a class="el" href="structderecho_1_1RawObject.html" title="An empty class to be used as the &quot;replicated type&quot; for a subgroup that doesn&#39;t implement a Replicated...">RawObject</a>, which is trivial because RawObjects have no state. </p>

<p class="definition">Definition at line <a class="el" href="replicated_8h_source.html#l00062">62</a> of file <a class="el" href="replicated_8h_source.html">replicated.h</a>.</p>

</div>
</div>
<a id="a7c7e09a1f5bcd4328c061fd3ba66c81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7e09a1f5bcd4328c061fd3ba66c81b">&#9670;&nbsp;</a></span>test_provision_subgroups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void derecho::test_provision_subgroups </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structderecho_1_1SubgroupInfo.html">SubgroupInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>subgroup_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; <a class="el" href="classderecho_1_1View.html">View</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>prev_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classderecho_1_1View.html">View</a> &amp;&#160;</td>
          <td class="paramname"><em>curr_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs the same logic as <a class="el" href="classderecho_1_1ViewManager.html#a77d57b8010168e5ac01ee10471e30ebf" title="Initializes curr_view with subgroup information based on the membership functions in subgroup_info...">ViewManager::make_subgroup_maps()</a>, only without actually saving the subgroup_to_x maps. </p>
<p>curr_view is still updated with the subgroup assignments, though. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subgroup_info</td><td>The <a class="el" href="structderecho_1_1SubgroupInfo.html" title="Container for whatever information is needed to describe a Group&#39;s subgroups and shards. ">SubgroupInfo</a> to use for provisioning subgroups </td></tr>
    <tr><td class="paramname">prev_view</td><td>The previous view, if there was one, or nullptr </td></tr>
    <tr><td class="paramname">curr_view</td><td>The current view in which to assign subgroup membership </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="subgroup__function__tester_8cpp_source.html#l00125">125</a> of file <a class="el" href="subgroup__function__tester_8cpp_source.html">subgroup_function_tester.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="abff622923a1263e778a2dcdbc07210d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff622923a1263e778a2dcdbc07210d2">&#9670;&nbsp;</a></span>index_of_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetType , typename... TypePack&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t derecho::index_of_type = <a class="el" href="namespacederecho.html#a1cde0180ea838f8ca4e5cd7b84959c0f">index_of_type_impl</a>&lt;0, TargetType, TypePack...&gt;()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A compile-time "function" that computes the index of a type within a template parameter pack of types. </p>
<p>The value of this constant is equal to the index of TargetType within TypePack. (The compiler will spew template errors if TargetType is not actually in TypePack). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TargetType</td><td>The type to search for in the parameter pack </td></tr>
    <tr><td class="paramname">TypePack</td><td>The template parameter pack that should be searched </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="group_8h_source.html#l00056">56</a> of file <a class="el" href="group_8h_source.html">group.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 4 2019 16:24:57 for Derecho by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
